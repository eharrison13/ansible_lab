# ###############################################################
# # Title:        Evaluate-STIG
# # Version:      1.2404.0
# # Description:  Automates STIG checklist (CKL) creation
# # Date:         05/01/2024
# ###############################################################

#requires -version 5.1

<#
    .Synopsis
        Automatically creates STIG checklists (CKL).
    .DESCRIPTION
        Automates the documentation of STIG compliance into STIG Viewer compatible checklist (.ckl) files.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1

        Runs Evaluate-STIG with default settings ("Unclassified" ScanType, "DEFAULT" Answer Key, and output to C:\Users\Public\Public Documents)
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -ScanType Classified -AnswerKey TestNetwork

        Runs Evaluate-STIG for a classified system and instructs it to use the user defined "TestNetwork" Answer Key.  Refer to documentation on answer keys.
    .EXAMPLE
        PS C:\> $Result = .\Evaluate-STIG.ps1

        Runs Evaluate-STIG for an unclassified asset using the DEFAULT answer key and returns the results into a variable named "Result".
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -ScanType Classified -ComputerName Workstation1

        Executes Classified scan on remote computer Workstation1.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -ComputerName Workstation1,Workstation2,C:\Computers.txt -AltCredential -ThrottleLimit 7

        Executes Unclassifed scan on multiple computer names and a list of computers using an alternate credential and limiting concurrent scans to 7.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -SelectSTIG MSEdge,Chrome,Win10

        Selects Microsoft Edge, Google Chrome, and Windows 10 (by shortname) to be scanned.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -ExcludeSTIG DotNET4,WinServer2019

        Excludes .NET 4 Framework and Windows Server 2019 from scan.  All other STIGs will be scanned if applicable.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -CiscoConfig C:\ShowTechFiles -ThrottleLimit 5 -VulnTimeout 5

        Recursively looks for supported Cisco show tech files in C:\ShowTechFiles, concurrently scans a maximum of 5 files at a time, and a 5 minute timeout for each Group ID.
    .INPUTS
        -ScanType <"Unclassified"|"Classified">
        Use to instruct Evaluate-STIG the classification of the asset.  Valid ScanTypes are "Unclassified" and "Classified".  If not specified, default will be "Unclassified".

        -Marking <String>
        Use to optionally set Marking in CKL and on header/footer of files generated by Evaluate-STIG.  Example use is "CUI"/"Confidential"/"Secret"/"Top Secret" but accepts any marking string.

        -VulnTimeout <Int16>
        Maximum time in minutes to allow a singular Group ID check to run.

        -AnswerKey <String>
        Use to instruct Evaluate-STIG which Answer Key to use for determining if a comment from an answer file should be applied.  Answer Keys are per Group ID and user-defined within the answer file.  If not specified, default Answer Key will be "DEFAULT".  Refer to documentation for more information.

        -AFPath <string>
        Path to Answer Files.  If not specified, defaults to $PsScriptRoot\AnswerFiles.

        -Output <"Console"|"CKL"|"CKLB"|"CombinedCKL"|"CombinedCKLB"|"STIGManager"|"Summary"|"OQE">
        Specify output type(s).  Use comma separation for multiple.  If not specified, output will be returned to console.

        -OutputPath <String>
        Sets the directory path for Evaluate-STIG to save output to (excluding STIGManager).  Requires -Output.  May be a local or UNC path.  If not specified, default path will be C:\Users\Public\Public Documents or \opt\.  If using -OutputPath with -ComputerName, ensure the host computer's account has write access to the path in -OutputPath.

        -PreviousToKeep <Int16>
        Number of previous scan results to retain.  Default is 0.  Requires -Output.

        -AllowDeprecated
        Enable scanning of STIGs that are no longer available on cyber.mil (deprecated).  By default, deprecated STIGs will not be scanned.

        -SelectSTIG <String>
        Specify which STIG(s) to scan.  Use Tab or CTRL+SPACE to properly select STIG(s) by its short name.  For deprecated STIGs, must call -AllowDeprecated first.  For multiple STIGs, separate with commas.  Cannot be specified with -ExcludeSTIG.

        -ExcludeSTIG <String>
        Specify which STIG(s) to exclude from the scan.  Use Tab or CTRL+SPACE to properly exclude STIG(s) by its short name.  For multiple STIGs, separate with commas.  Cannot be specified with -SelectSTIG.

        -ForceSTIG <String>
        Ignore detection of STIG applicability and forcefully run a scan of selected STIG(s).  Use Tab or CTRL+SPACE to properly select STIG(s) by its short name.  For multiple STIGs, separate with commas.  *WARNING* Evaluate-STIG results are not guaranteed with this option.  Use at own risk. *WARNING*

        -SelectVuln <String>
        Specify which Group ID(s) to scan (V-#####).  For multiple, separate with commas.  Can only be used with -SelectSTIG.

        -ExcludeVuln <String>
        Specify which Group ID(s) to exclude from a scan (V-#####).  For multiple, separate with commas.  Can only be used with -SelectSTIG.

        -ComputerName <String>
        Execute scan on remote computer.  Supports multiple computers through comma separation. Can be a computer name, a file with a list of computers, or a combination.  By default, results will be copied back to source computer.  Requires admin rights on remote computer.

        -CiscoConfig <String>
        Execute a scan of Cisco show tech files.  May be a path to a single file, a folder, or combination using comma separation.

        -ThrottleLimit <Int16>
        Number of concurrent Evaluate-STIG jobs to run when using -ComputerName or -CiscoConfig.  Default is 10. Requires -ComputerName or -CiscoConfig input.

        -AltCredential
        Prompts for an alternate credential to use for remote scans.  If connection to the remote machine fails with the alternate credential, Evaluate-STIG will fallback to the launching user and attempt the connection - essentially allowing for two credentials to be used for remote scan (e.g. workstation/server credentials).  Requires -ComputerName input.  Windows only.

        -SMCollection <String>
        Use to instruct Evaluate-STIG which STIGManager Collection to upload results.  Requires -Output STIGManager.

        -SMPassphrase <String>
        Passphrase to decrpyt private key if encrypted .key is used for authentication to a STIGManager instance.  Requires -Output STIGManager.

        -ApplyTattoo
        Applies Evaluate-STIG tattooing on system.  Mainly for providing a detection method to configuration management tools.

        -ListSupportedProducts
        Lists all products that Evaluate-STIG currently supports.

        -ListApplicableProducts
        Lists all Evaluate-STIG supported STIGs that are applicable to the asset.

        -Version
        Display Evaluate-STIG version and running path.

        -Update
        Downloads updates to Evaluate-STIG from the Evaluate-STIG repo on SPORK.

        -LocalSource
        Directs -Update to download updates to Evaluate-STIG from a local Evaluate-STIG directory.

        -Proxy <String>
        Configure proxy for use with -Update.
    .LINK
        Evaluate-STIG
        https://spork.navsea.navy.mil/nswc-crane-division/evaluate-stig
        https://intelshare.intelink.gov/sites/NAVSEA-RMF

        Windows Remote Management (WinRM)
        https://docs.microsoft.com/en-us/windows/win32/winrm

        CMTrace (for viewing EValuate-STIG.log)
        https://docs.microsoft/en-us/configmgr/core/support/cmtrace
    #>

[CmdletBinding(PositionalBinding = $false)]
Param (
    [Parameter(Mandatory = $false)]
    [String[]]$ComputerName,

    [Parameter(Mandatory = $false)]
    [String[]]$CiscoConfig,

    # TODO: Staging VMWare Content
    # TODO: Need to require -VCenterApplianceName for -VMName, but do NOT need the inverse.
    #[Parameter(Mandatory = $false)]
    #[String[]]$VCenterApplianceName,

    #[Parameter(Mandatory = $false)]
    #[String[]]$VMName,

    [Parameter(Mandatory = $false)]
    [ValidateSet("Unclassified", "Classified")]
    [String]$ScanType = "Unclassified",

    [Parameter(Mandatory = $false)]
    [String]$Marking,

    [Parameter(Mandatory = $false)]
    [Int16]$VulnTimeout = 15,

    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [String]$AFPath,

    [Parameter(Mandatory = $false)]
    [String]$AnswerKey = "DEFAULT",

    # Code for -Output Option
    # https://powershell.one/powershell-internals/attributes/autocompletion
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [ArgumentCompleter({
            # Recieve information about current state to assit in auto-completing user typed value
            Param($CommandName, $ParameterName, $WordToComplete, $CommandAst, $FakeBoundParameters)

            $ValidValues = @("Console", "CKL", "CKLB", "CombinedCKL", "CombinedCKLB", "STIGManager", "Summary", "OQE")
            $ValidValues | Where-Object { $_ -like "$WordToComplete*" }
        })]
    [ValidateScript({
            $ValidValues = @("Console", "CKL", "CKLB", "CombinedCKL", "CombinedCKLB", "STIGManager", "Summary", "OQE")
            ForEach ($Value in ($_ -split ",")) {
                If ($Value -notin $ValidValues) {
                    Throw "`r`n `r`n'$_' is not a valid Output.  Valid Output entries include $($ValidValues -join ", ")`r`n `r`n"
                }
            }
            $true
        })]
    [String[]]$Output = "Console",

    [Parameter(Mandatory = $false)]
    [String]$OutputPath,

    [Parameter(Mandatory = $false)]
    [Switch]$ApplyTattoo,

    [Parameter(Mandatory = $false)]
    [Switch]$ListApplicableProducts,

    [Parameter(Mandatory = $false)]
    [Switch]$ListSupportedProducts,

    [Parameter(Mandatory = $false)]
    [Switch]$AllowDeprecated,

    [Parameter(Mandatory = $false)]
    [Switch]$Version,

    [Parameter(Mandatory = $false)]
    [Switch]$Update,

    # Code for -SelectSTIG Option
    # https://powershell.one/powershell-internals/attributes/autocompletion
    [Parameter(ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [ArgumentCompleter({
            # Recieve information about current state to assist in auto-completing user typed value
            Param($CommandName, $ParameterName, $WordToComplete, $CommandAst, $FakeBoundParameters)

            # Get STIG ShortNames from STIGList.xml
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                If ($CommandAst.Parent.PipeLineElements -match "-AllowDeprecated") {
                    $STIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Select-Object Name, ShortName -Unique | Sort-Object ShortName
                }
                Else {
                    $STIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object Deprecated -eq $false | Select-Object Name, ShortName -Unique | Sort-Object ShortName
                }

                # Compose CompletionResult Entries
                $STIGs | Where-Object {$_.Shortname} | Where-Object {$_.ShortName -like "$WordToComplete*"} | ForEach-Object {
                    $STIGSN = $_.Shortname
                    If ($STIGSN -like '* *') {
                        $STIGSN = "'$STIGSN'"
                    }
                    [Management.Automation.CompletionResult]::New($STIGSN, $STIGSN, "ParameterValue", $_.Name)
                }
            }
        })]
    [ValidateScript({
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            $PrefsXML = Join-Path $PsScriptRoot -ChildPath "Preferences.xml"
            If (Test-Path $STIGListXML) {
                $ValidSTIGs = (([XML](Get-Content $STIGListXML)).List.STIG | Where-Object Deprecated -eq $false).ShortName
                $DeprecatedSTIGs = (([XML](Get-Content $STIGListXML)).List.STIG | Where-Object Deprecated -eq $true).ShortName
                If (Test-Path $PrefsXML) {
                    $PrefAllowDep = ((Select-Xml -Path $PrefsXML -XPath "/" | Select-Object -ExpandProperty Node).Preferences.EvaluateSTIG.AllowDeprecated).Trim()
                }
                $_ -Split "," | ForEach-Object {
                    If (($_ -in $ValidSTIGs) -or ($_ -in $DeprecatedSTIGs -and ($PSBoundParameters.Keys -contains "AllowDeprecated" -or $PrefAllowDep -eq "true"))) {
                        $true
                    }
                    ElseIf ($DeprecatedSTIGs -contains $_) {
                        Throw "`r`n `r`n'$_' is a deprecated STIG.  Please use '-AllowDeprecated' to enable deprecated STIG scans.`r`n `r`n"
                    }
                    Else {
                        Throw "`r`n `r`n'$_' is not a product supported by Evaluate-STIG.  Please use CTRL+SPACE to list valid products.`r`n `r`n"
                    }
                }
            }
            Else {
                Throw "`r`n `r`n'$STIGListXML' does not exist.  Cannot continue.`r`n `r`n"
            }
        })]
    [Array]$SelectSTIG,

    # Code for -ExcludeSTIG Option
    # https://powershell.one/powershell-internals/attributes/autocompletion
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [ArgumentCompleter({
            # Recieve information about current state to assist in auto-completing user typed value
            Param($CommandName, $ParameterName, $WordToComplete, $CommandAst, $FakeBoundParameters)

            # Get STIG ShortNames from STIGList.xml
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                $STIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Select-Object Name, ShortName -Unique | Sort-Object ShortName

                # Compose CompletionResult Entries
                $STIGs | Where-Object {$_.Shortname} | Where-Object {$_.ShortName -like "$WordToComplete*"} | ForEach-Object {
                    $STIGSN = $_.Shortname
                    If ($STIGSN -like '* *') {
                        $STIGSN = "'$STIGSN'"
                    }
                    [Management.Automation.CompletionResult]::New($STIGSN, $STIGSN, "ParameterValue", $_.Name)
                }
            }
        })]
    [ValidateScript( {
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                $ValidSTIGs = (([XML](Get-Content $STIGListXML)).List.STIG).ShortName
                $_ -Split "," | ForEach-Object {
                    If ($_ -in $ValidSTIGs) {
                        $true
                    }
                    Else {
                        Throw "`r`n `r`n'$_' is not a product supported by Evaluate-STIG.  Please use CTRL+SPACE to list valid products.`r`n `r`n"
                    }
                }
            }
            Else {
                Throw "`r`n `r`n'$STIGListXML' does not exist.  Cannot continue.`r`n `r`n"
            }
        })]
    [Array]$ExcludeSTIG,

    # Code for -ForceSTIG Option
    # https://powershell.one/powershell-internals/attributes/autocompletion
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [ArgumentCompleter({
            # Recieve information about current state to assist in auto-completing user typed value
            Param($CommandName, $ParameterName, $WordToComplete, $CommandAst, $FakeBoundParameters)

            # Get STIG ShortNames from STIGList.xml
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                $STIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Select-Object Name, ShortName -Unique | Sort-Object ShortName

                # Compose CompletionResult Entries
                $STIGs | Where-Object {$_.Shortname} | Where-Object {$_.ShortName -like "$WordToComplete*"} | ForEach-Object {
                    $STIGSN = $_.Shortname
                    If ($STIGSN -like '* *') {
                        $STIGSN = "'$STIGSN'"
                    }
                    [Management.Automation.CompletionResult]::New($STIGSN, $STIGSN, "ParameterValue", $_.Name)
                }
            }
        })]
    [ValidateScript({
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                $ValidSTIGs = (([XML](Get-Content $STIGListXML)).List.STIG).ShortName
                $_ -Split "," | ForEach-Object {
                    If ($_ -in $ValidSTIGs) {
                        $true
                    }
                    Else {
                        Throw "`r`n `r`n'$_' is not a product supported by Evaluate-STIG.  Please use CTRL+SPACE to list valid products.`r`n `r`n"
                    }
                }
            }
            Else {
                Throw "`r`n `r`n'$STIGListXML' does not exist.  Cannot continue.`r`n `r`n"
            }
        })]
    [Array]$ForceSTIG
)

# Expose addtional dynamic parameters
DynamicParam {
    $ParamDictionary = New-Object System.Management.Automation.RuntimeDefinedParameterDictionary

    If ($ComputerName -and (-Not($IsLinux)) -or $CiscoConfig -or $VCenterApplianceName -or $VMName) {
        If ($ComputerName -or ($VCenterApplianceName -or $VMName)) {
            # Expose -AltCredential if -ComputerName is specified
            $Attributes = New-Object System.Management.Automation.ParameterAttribute
            $Attributes.Mandatory = $false
            $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $AttributeCollection.Add($Attributes)
            $CredParam = New-Object System.Management.Automation.RuntimeDefinedParameter("AltCredential", [Switch], $AttributeCollection)
            $ParamDictionary.Add("AltCredential", $CredParam)
        }

        # Expose -ThrottleLimit
        $Attributes = New-Object System.Management.Automation.ParameterAttribute
        $Attributes.Mandatory = $false
        $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
        $AttributeCollection.Add($Attributes)
        $ThrottleParam = New-Object System.Management.Automation.RuntimeDefinedParameter("ThrottleLimit", [Int16], $AttributeCollection)
        $ParamDictionary.Add("ThrottleLimit", $ThrottleParam)
    }

    If ($Update) {
        # Expose -Proxy
        $Attributes = New-Object System.Management.Automation.ParameterAttribute
        $Attributes.Mandatory = $false
        $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
        $AttributeCollection.Add($Attributes)
        $ProxyParam = New-Object System.Management.Automation.RuntimeDefinedParameter("Proxy", [String], $AttributeCollection)
        $ParamDictionary.Add("Proxy", $ProxyParam)

        #Expose -LocalSource
        $Attributes = New-Object System.Management.Automation.ParameterAttribute
        $Attributes.Mandatory = $false
        $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
        $AttributeCollection.Add($Attributes)
        $LocalSourceParam = New-Object System.Management.Automation.RuntimeDefinedParameter("LocalSource", [String], $AttributeCollection)
        $ParamDictionary.Add("LocalSource", $LocalSourceParam)
    }

    If ($Output) {
        If (($Output -Split ",").Trim() -match @("(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$|^Summary$|^OQE$)")) {
            # Expose -PreviousToKeep
            $Attributes = New-Object System.Management.Automation.ParameterAttribute
            $Attributes.Mandatory = $false
            $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $AttributeCollection.Add($Attributes)
            $PreviousToKeepParam = New-Object System.Management.Automation.RuntimeDefinedParameter("PreviousToKeep", [Int16], $AttributeCollection)
            $ParamDictionary.Add("PreviousToKeep", $PreviousToKeepParam)
        }

        If (($Output -Split ",").Trim() -match "^STIGManager$") {
            # Expose -SMPassphrase
            $Attributes = New-Object System.Management.Automation.ParameterAttribute
            $Attributes.Mandatory = $false
            $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $AttributeCollection.Add($Attributes)
            $SMPassphraseParam = New-Object System.Management.Automation.RuntimeDefinedParameter("SMPassphrase", [String], $AttributeCollection)
            $ParamDictionary.Add("SMPassphrase", $SMPassphraseParam)

            # Expose -SMCollection
            $Attributes = New-Object System.Management.Automation.ParameterAttribute
            $Attributes.Mandatory = $false
            $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $AttributeCollection.Add($Attributes)
            $SMCollectionParam = New-Object System.Management.Automation.RuntimeDefinedParameter("SMCollection", [String], $AttributeCollection)
            $ParamDictionary.Add("SMCollection", $SMCollectionParam)
        }
    }

    If ($SelectSTIG) {
        # Expose -SelectVuln
        $Attributes = New-Object System.Management.Automation.ParameterAttribute
        $Attributes.Mandatory = $false
        $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
        $AttributeCollection.Add($Attributes)
        $SelectVulnParam = New-Object System.Management.Automation.RuntimeDefinedParameter("SelectVuln", [Array], $AttributeCollection)
        $ParamDictionary.Add("SelectVuln", $SelectVulnParam)

        # Expose -ExcludeVuln
        $Attributes = New-Object System.Management.Automation.ParameterAttribute
        $Attributes.Mandatory = $false
        $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
        $AttributeCollection.Add($Attributes)
        $ExcludeVulnParam = New-Object System.Management.Automation.RuntimeDefinedParameter("ExcludeVuln", [Array], $AttributeCollection)
        $ParamDictionary.Add("ExcludeVuln", $ExcludeVulnParam)
    }

    Return $ParamDictionary
}

Process {
    Write-Host "" # Just a blank line in console for readability

    # -Update and external scripts reference the below $EvaluateStigVersion line as written.  Do not modify.
    $EvaluateStigVersion = "1.2404.0"

    # Collect dynamic / prepare array parameters
    If ($ComputerName) {
        $ComputerName = $ComputerName -Split ","
    }
    If ($CiscoConfig) {
        $CiscoConfig = $CiscoConfig -Split ","
    }
    If ($Output) {
        $Output = $Output -Split ","
    }
    If ($SelectSTIG) {
        $SelectSTIG = $SelectSTIG -Split ","
    }
    If ($ExcludeSTIG) {
        $ExcludeSTIG = $ExcludeSTIG -Split ","
    }
    If ($ForceSTIG) {
        $ForceSTIG = $ForceSTIG -Split ","
    }
    If ($PsBoundParameters.OutputPath) {
        $OutputPath = $PsBoundParameters.OutputPath
    }
    If ("PreviousToKeep" -in $PsBoundParameters.Keys) {
        $PreviousToKeep = $PsBoundParameters.PreviousToKeep
    }
    Else {
        $PreviousToKeep = 1
    }
    If ($PsBoundParameters.AltCredential) {
        $AltCredential = "{0}" -f $PsBoundParameters.AltCredential
    }
    If ($PsBoundParameters.SelectVuln) {
        $SelectVuln = ($PsBoundParameters.SelectVuln -Split ",").Trim() | Sort-Object -Unique
    }
    If ($PsBoundParameters.ExcludeVuln) {
        $ExcludeVuln = ($PsBoundParameters.ExcludeVuln -Split ",").Trim() | Sort-Object -Unique
    }
    If ($PsBoundParameters.ThrottleLimit) {
        $ThrottleLimit = $PsBoundParameters.ThrottleLimit
    }
    If ($PSBoundParameters.SMPassphrase) {
        $SMPassphrase = $PsBoundParameters.SMPassphrase | ConvertTo-SecureString -AsPlainText -Force
    }
    If ($PSBoundParameters.SMCollection) {
        $SMCollection = $PsBoundParameters.SMCollection
    }

    # ---------- Begin Prechecks ----------
    # Get PowerShell version and OS platform (Linux or Windows).  If unsupported detected, fail out.
    Try {
        $PowerShellVersion = $PsVersionTable.PSVersion
        If ($PowerShellVersion -ge [Version]"7.0") {
            If ($PowerShellVersion -ge [Version]"7.2") {
                $PSStyle.Progress.View = "Classic"
                $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::PlainText;
            }
            If ($IsLinux -eq $true) {
                $OSPlatform = "Linux"
            }
            If ($IsWindows -eq $true) {
                $OSPlatform = "Windows"
                [Version]$WMFVersion = (PowerShell.exe -Command {$PsVersionTable}).PsVersion
                If ($WMFVersion -lt [Version]"5.1") {
                    Throw "Windows Management Framework (WMF) $($WMFVersion -join '.') detected.  WMF 5.1 or greater is required."
                }
            }
        }
        ElseIf ($PowerShellVersion -lt [Version]"5.1" -or ($PowerShellVersion -join ".") -like "6.*") {
            Throw "PowerShell $($PowerShellVersion -join '.') detected.  Evaluate-STIG only supports PowerShell 5.1 or PowerShell 7.x and greater.  PowerShell 6.x is not supported."
        }
        Else {
            $OSPlatform = "Windows"
        }
    }
    Catch {
        Write-Host "$($_.Exception.Message)" -ForegroundColor Red
        Return
    }

    # Import required modules
    If (Test-Path (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Master_Functions")) {
        Try {
            If ($PowerShellVersion -lt [Version]"7.0") {
                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Master_Functions") -ErrorAction Stop
            }
            Else {
                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Master_Functions") -SkipEditionCheck -ErrorAction Stop
            }
        }
        Catch {
            Write-Host "$($_.Exception.Message)" -ForegroundColor Red
            Exit 1
        }
    }
    Else {
        Write-Host "ERROR: 'Master_Functions' module not found.  Unable to continue." -ForegroundColor Red
        Exit 3
    }

    # If -ListApplicableProducts, -ListSupportedProducts, or -Version are specified and not the only param specified, error out.
    Try {
        If (($PsBoundParameters.Keys | Measure-Object).Count -gt 1) {
            ForEach ($Key in $PsBoundParameters.Keys) {
                If ($Key -in @("ListApplicableProducts", "ListSupportedProducts", "Version")) {
                    Throw "-$Key must not have additional parameters specified."
                }
            }
        }
    }
    Catch {
        Write-Host "$($_.Exception.Message)" -ForegroundColor Red
        Return
    }

    # If both -ComputerName and -CiscoConfig are specified, error out.  Only one may be specified.
    Try {
        If (($ComputerName) -and ($CiscoConfig -or $VCenterApplianceName)) {
            Throw "-ComputerName and -CiscoConfig cannot both be specified."
            # TODO: Swap the below line IN once VCenter is supported
            #Throw "Cannot specify more than one these parameters at a time: -ComputerName, -CiscoConfig or $VCenterApplianceName."
        }
    }
    Catch {
        Write-Host "$($_.Exception.Message)" -ForegroundColor Red
        Return
    }

    # If both -SelectSTIG and -ExcludeSTIG are specified, error out.  Only one may be specified.
    Try {
        If (($SelectSTIG) -and ($ExcludeSTIG)) {
            Throw "-SelectSTIG and -ExcludeSTIG cannot both be specified."
        }
    }
    Catch {
        Write-Host "$($_.Exception.Message)" -ForegroundColor Red
        Return
    }

    # Confirm -SelectVuln/-ExcludeVuln are properly formatted
    Try {
        If ($SelectVuln) {
            ForEach ($Item in $SelectVuln) {
                If ($Item -notmatch "^V-\d{4,6}$") {
                    Throw "$Item is an invalid entry for -SelectVuln.  Must be V-####."
                }
            }
        }
        ElseIf ($ExcludeVuln) {
            ForEach ($Item in $ExcludeVuln) {
                If ($Item -notmatch "^V-\d{4,6}$") {
                    Throw "$Item is an invalid entry for -ExcludeVuln.  Must be V-####."
                }
            }
        }
    }
    Catch {
        Write-Host "$($_.Exception.Message)" -ForegroundColor Red
        Return
    }
    # ---------- Begin Prechecks ----------

    # ---------- Begin Utility Parameters ----------
    # If -ListSupportedSTIGs specified, display list and exit.
    If ($ListSupportedProducts) {
        Try {
            $STIGList_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_STIGList.xsd"
            $XmlFile = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (-Not(Test-Path $XmlFile)) {
                Throw "'$Xmlfile' file not found.  Please update with -Update option."
            }
            ElseIf (-Not(Test-Path $STIGList_xsd)) {
                Throw "'$STIGList_xsd' file not found.  Please update with -Update option."
            }
            ElseIf ((Test-XmlValidation -XmlFile $XmlFile -SchemaFile $STIGList_xsd) -ne $true) {
                Throw "'$Xmlfile' failed schema validation.  Please update with -Update option."
            }

            # Get list of supported STIGs
            $Result = (Get-SupportedProducts -ES_Path $PsScriptRoot)

            # Remove InstalledSoftware variable if it exists
            If ($null -ne $Global:InstalledSoftware) {
                Remove-Variable -Name InstalledSoftware -Scope Global
            }

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

            Return $Result
        }
        Catch {
            Write-Host "$($_.Exception.Message)" -ForegroundColor Red

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

            Exit 1
        }
    }

    # If -ListApplicableProducts specified, display list and exit.
    If ($ListApplicableProducts) {
        Try {
            # Confirm we have an elevated session.
            Switch ($OSPlatform) {
                "Windows" {
                    If (-NOT([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator") -and !$AltCredential -and ($LinuxList.count -eq 0)) {
                        Throw "You must run this from an elevated PowerShell session or use -AltCredential."
                    }
                }
                "Linux" {
                    If ((id -u) -ne 0) {
                        Throw "You must run this from an elevated PowerShell session."
                    }
                }
            }

            $STIGList_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_STIGList.xsd"
            $XmlFile = Join-Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (-Not(Test-Path $XmlFile)) {
                Throw "'$Xmlfile' file not found.  Please update with -Update option."
            }
            ElseIf (-Not(Test-Path $STIGList_xsd)) {
                Throw "'$STIGList_xsd' file not found.  Please update with -Update option."
            }
            ElseIf ((Test-XmlValidation -XmlFile $XmlFile -SchemaFile $STIGList_xsd) -ne $true) {
                Throw "'$Xmlfile' failed schema validation.  Please update with -Update option."
            }

            # Get list of applicable STIGs
            $Result = (Get-ApplicableProducts -ES_Path $PsScriptRoot)

            # Remove InstalledSoftware variable if it exists
            If ($null -ne $Global:InstalledSoftware) {
                Remove-Variable -Name InstalledSoftware -Scope Global
            }

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

            Return $Result
        }
        Catch {
            Write-Host "$($_.Exception.Message)" -ForegroundColor Red

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

            Exit 1
        }
    }

    # If -Version specified, display its output.
    If ($Version) {
        Try {
            $Result = [PSCustomObject]@{
                Version     = $EvaluateStigVersion
                RunningPath = $PSScriptRoot
            }
            Return $Result
        }
        Catch {
            Write-Host "$($_.Exception.Message)" -ForegroundColor Red
            Exit 1
        }
    }

    # If -Update specified, download the latest updates.
    If ($Update) {
        If ($PSBoundParameters.LocalSource) {
            $LocalSource = $PSBoundParameters.LocalSource
        }
        #Validated LocalSource
        $Verified = $true
        if ($LocalSource){
            If (Test-Path (Join-Path -Path $LocalSource -ChildPath "xml" | Join-Path -ChildPath "FileList.xml")) {
                [XML]$FileListXML = Get-Content -Path (Join-Path -Path $LocalSource -ChildPath "xml" | Join-Path -ChildPath "FileList.xml")
                If ((Test-XmlSignature -checkxml $FileListXML -Force) -ne $true) {
                    Write-Host "ERROR: 'FileList.xml' in $LocalSource failed authenticity check.  Unable to verify content integrity." -ForegroundColor Red
                    exit 1
                }
                Else {
                    Write-host "Checking $LocalSource file integrity..." -ForegroundColor Cyan
                    ForEach ($File in $FileListXML.FileList.File) {
                        $Path = (Join-Path -Path $LocalSource -ChildPath $File.Path | Join-Path -ChildPath $File.Name)
                        If (Test-Path $Path) {
                            If ((Get-FileHash -Path $Path -Algorithm SHA256).Hash -ne $File.SHA256Hash) {
                                $Verified = $false
                            }
                        }
                        else{
                            If ($File.ScanReq -ne "Optional") {
                                $Verified = $false
                            }
                        }
                    }
                    If ($Verified -eq $true) {
                        Write-Host "$LocalSource file integrity check passed." -ForegroundColor Green
                    }
                    Else {
                        Write-Host "$LocalSource file integrity check failed." -ForegroundColor Red
                        Throw "$LocalSource file integrity check failed."
                    }
                }
            }
            Else {
                Write-Host "ERROR: 'FileList.xml' in $LocalSource not found.  Unable to verify content integrity." -ForegroundColor Red
                exit 1
            }
        }
        if (!$LocalSource){
            $FirstPass = $false
            Try {
                If ($PSBoundParameters.Proxy) {
                    $Proxy = $PSBoundParameters.Proxy
                }
                If ($LocalSource){
                    $UpdateMessage = Get-FileUpdatesFromRepo -PS_Path $PsScriptRoot -Proxy $Proxy -LocalSource $LocalSource
                }
                else{
                    $UpdateMessage = Get-FileUpdatesFromRepo -PS_Path $PsScriptRoot -Proxy $Proxy
                }
                Switch -Wildcard ($UpdateMessage) {
                    "Successfully updated*" {
                        $FirstPass = $True
                    }
                    "*requires no updating." {
                        Write-Host $_ -ForegroundColor Cyan

                        # Remove Evaluate-STIG modules from memory
                        Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
                        Exit
                    }
                    default {
                        Throw $_
                    }
                }

                # Remove Evaluate-STIG modules from memory
                Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
            }
            Catch {
                Write-Host "$($_.Exception.Message)" -ForegroundColor Red

                # Remove Evaluate-STIG modules from memory
                Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

                Exit 1
            }
        }

        if ($FirstPass -or $LocalSource){
            # Import Updated modules
            Try{
                If (Test-Path (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Master_Functions")) {
                    Try {
                        If ($PowerShellVersion -lt [Version]"7.0") {
                            Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Master_Functions") -ErrorAction Stop
                        }
                        Else {
                            Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Master_Functions") -SkipEditionCheck -ErrorAction Stop
                        }
                    }
                    Catch {
                        Write-Host "$($_.Exception.Message)" -ForegroundColor Red
                        Exit 1
                    }
                }
                Else {
                    Write-Host "ERROR: Updated 'Master_Functions' module not found.  Unable to continue." -ForegroundColor Red
                    Exit 3
                }

                If ($LocalSource){
                    $UpdateMessage = Get-FileUpdatesFromRepo -PS_Path $PsScriptRoot -Proxy $Proxy -LocalSource $LocalSource -SecondPass
                }
                else{
                    $UpdateMessage = Get-FileUpdatesFromRepo -PS_Path $PsScriptRoot -Proxy $Proxy -SecondPass
                }
                Switch -Wildcard ($UpdateMessage) {
                    "Successfully updated*" {
                        Write-host $(($_ -split "`r`n")[0]) -ForegroundColor Green
                        if ($(($_ -split "`r`n")[1])){Write-Host $(($_ -split "`r`n")[1]) -ForegroundColor Yellow}
                    }
                    default {
                        Throw $_
                    }
                }

                # Remove Evaluate-STIG modules from memory
                Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

                Exit
            }
            Catch {
                Write-Host "$($_.Exception.Message)" -ForegroundColor Red

                # Remove Evaluate-STIG modules from memory
                Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

                Exit 1
            }
        }
        else{
            Switch -Wildcard ($UpdateMessage) {
                "Successfully updated*" {
                    Write-Host $_ -ForegroundColor Green
                    exit
                }
                default {
                    Write-Host $_ -ForegroundColor Red
                    exit 1
                }
            }
        }
    }
    # ---------- Begin Utility Parameters ----------

    # Read in Preferences.xml and set parameters if not called from command line
    Try {
        $Preferences_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_Preferences.xsd"
        $Preferences_xml = Join-Path -Path $PsScriptRoot -ChildPath "Preferences.xml"
        If (Test-Path $Preferences_xml) {
            $ParameterList = (Get-Command -Name (Join-Path $PsScriptRoot -ChildPath ($MyInvocation.MyCommand))).Parameters

            # Validate Preferences.xml against schema
            If (-Not(Test-Path $Preferences_xsd)) {
                Throw "'$Preferences_xsd' file not found.  Please update with -Update option."
            }
            Else {
                $Valid = Test-XmlValidation -XmlFile $Preferences_xml -SchemaFile $Preferences_xsd
                If ($Valid -ne $true) {
                    $Msg = "'$Preferences_xml' failed schema validation." | Out-String
                    $Msg += $Valid.Message | Out-String
                    Throw $Msg
                }
            }

            # Set parameters defined in Preferences.xml.  Parameters called from command line override Preferences.xml
            $Preferences = (Select-Xml -Path $Preferences_xml -XPath /).Node
            $InUsePrefs = New-Object System.Collections.Generic.List[System.Object]
            ForEach ($Item in ($Preferences.Preferences.EvaluateSTIG | Get-Member -MemberType Property | Where-Object Name -NE '#comment').Name) {
                If ($Preferences.Preferences.EvaluateSTIG.$Item -ne '' -and (-Not($Item -in $PSBoundParameters.Keys))) {
                    $InUsePrefs.Add($Item)
                    # Prerequisite param must be verified before setting dynamic param
                    Switch ($Item) {
                        "ExcludeVuln" {
                            $Prereq = @("SelectSTIG")
                            ForEach ($obj in $Prereq) {
                                # Dynamic parameters must be added to $PSBoundParameters
                                If ($PSBoundParameters.Keys -contains $obj) {
                                    $PSBoundParameters.Add($Item, $($Preferences.Preferences.EvaluateSTIG.$Item -replace '"', '' -replace "'", ''))
                                    Break
                                }
                            }
                        }
                        DEFAULT {
                            # Static parameters must have their variable set
                            Try {
                                If ($ParameterList[$Item].ParameterType.Name -eq "SwitchParameter") {
                                    Set-Variable -Name $Item -Value $([System.Convert]::ToBoolean($($Preferences.Preferences.EvaluateSTIG.$Item -replace '"', '' -replace "'", '')))
                                }
                                ElseIf ($ParameterList[$Item].ParameterType.Name -eq "String[]") {
                                    Set-Variable -Name $Item -Value $([String[]]$Preferences.Preferences.EvaluateSTIG.$Item -Split ",")
                                }
                                ElseIf ($ParameterList[$Item].ParameterType.Name -eq "Array") {
                                    Set-Variable -Name $Item -Value $([String[]]$Preferences.Preferences.EvaluateSTIG.$Item -Split ",")
                                }
                                Else {
                                    Set-Variable -Name $Item -Value $($Preferences.Preferences.EvaluateSTIG.$Item -replace '"', '' -replace "'", '')
                                }
                            }
                            Catch {
                                $Msg = "Invalid entry in Preferences.xml for '$Item'" | Out-String
                                If ((Get-Variable $Item).Attributes.ValidValues) {
                                    $Msg += "Valid values include $((Get-Variable $Item).Attributes.ValidValues -join ', ')" | Out-String
                                }
                                $Msg += $_.Exception.Message | Out-String
                                Throw $Msg
                            }
                        }
                    }
                }
            }
        }
    }
    Catch {
        Write-Host "$($_.Exception.Message)" -ForegroundColor Red
        Return
    }

    if ($Output -match "^STIGManager$") {
        Try {
            If ($PowerShellVersion -le [Version]"7.0") {
                Throw "PowerShell $($PowerShellVersion -join '.') detected.  STIGManager integration requires PowerShell 7.x and greater."
            }

            ForEach ($Item in ($Preferences.Preferences.STIGManager | Get-Member -MemberType Property | Where-Object Definition -MATCH string | Where-Object Name -NE '#comment').Name) {
                    $Preferences.Preferences.STIGManager.$Item = $Preferences.Preferences.STIGManager.$Item -replace '"','' -replace "'",''
            }

            #Validate STIGMan Preferences
            if (!($Preferences.Preferences.STIGManager.SMImport_API_BASE)){
                Throw "STIGManager preferences missing SMImport_API_BASE."
            }
            if (!($Preferences.Preferences.STIGManager.SMImport_AUTHORITY)){
                Throw "STIGManager preferences missing SMImport_AUTHORITY."
            }

            if ($Preferences.Preferences.STIGManager | Select-Object -ExpandProperty SMImport_COLLECTION | Where-Object Name -EQ $SMCollection){
                $STIGManagerObject = $Preferences.Preferences.STIGManager | Select-Object -ExpandProperty SMImport_COLLECTION | Where-Object Name -EQ $SMCollection

                ForEach ($Item in ($STIGManagerObject | Get-Member -MemberType Property | Where-Object Definition -MATCH string).Name) {
                    $STIGManagerObject.$Item = $STIGManagerObject.$Item -replace '"','' -replace "'",''
                }
            }
            else{
                Throw "STIGManager: $SMCollection not found or parameter missing."
            }
            if (!($STIGManagerObject.SMImport_CLIENT_ID)){
                Throw "STIGManager preferences missing SMImport_CLIENT_ID."
            }
            if (!($STIGManagerObject.SMImport_COLLECTION_ID)){
                Throw "STIGManager preferences missing SMImport_COLLECTION_ID."
            }
            if (!(Test-Path $STIGManagerObject.SMImport_CLIENT_CERT)){
                Throw "STIGManager preferences missing SMImport_CLIENT_CERT or file not found."
            }
            If ($STIGManagerObject.SMImport_CLIENT_CERT_KEY){
                if (Test-Path $STIGManagerObject.SMImport_CLIENT_CERT_KEY){
                    if ($STIGManagerObject.SMImport_CLIENT_CERT_KEY -and (!($SMPassphrase))){
                        Throw "STIGManager Key detected but no Passphrase was provided."
                    }
                }
                else{
                    Throw "STIGManager preferences missing SMImport_CLIENT_CERT_KEY or file not found."
                }
            }
        }
        Catch {
            Write-Host "$($_.Exception.Message)" -ForegroundColor Red
            Exit 1
        }
    }

    # Validate AFPath
    If ($AFPath) {
        Try {
            If (-Not($AFPath | Test-Path)) {
                Throw "-AFPath either does not exist or is not accessible."
            }
            ElseIf (($AFPath | Test-Path) -and (-Not($AFPath | Test-Path -PathType 'Container' -ErrorAction SilentlyContinue))) {
                Throw "-AFPath must point to a directory."
            }
        }
        Catch {
            Write-Host "$($_.Exception.Message)" -ForegroundColor Red
            Exit 1
        }
    }

    # Validate OutputPath
    If ($Output -match @("(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$|^Summary$|^OQE$)")) {
        Try {
            Switch ($OSPlatform) {
                "Windows" {
                    $DefaultOutputPath = [IO.Path]::GetFullPath("$($env:PUBLIC)\Documents\STIG_Compliance")
                    If ((-Not($OutputPath)) -or [IO.Path]::GetFullPath($(($OutputPath).Replace("/", "\")) -replace "\\$") -eq $DefaultOutputPath) {
                        $OutputPath = "$env:PUBLIC\Documents\STIG_Compliance"
                        If (-Not(Test-Path $OutputPath)) {
                            $null = New-Item -Path $(Split-Path -Path $OutputPath -Parent) -Name $(Split-Path -Path $OutputPath -Leaf) -ItemType Directory
                        }
                    }
                }
                "Linux" {
                    $DefaultOutputPath = [IO.Path]::GetFullPath("\opt\STIG_Compliance")
                    If ((-Not($OutputPath)) -or [IO.Path]::GetFullPath($(($OutputPath).Replace("\", "/")) -replace "/$") -eq $DefaultOutputPath) {
                        $OutputPath = "/opt/STIG_Compliance"
                        If (-Not(Test-Path $OutputPath)) {
                            sudo mkdir $OutputPath
                        }
                    }
                }
            }
            If (-Not($OutputPath | Test-Path)) {
                Throw "-OutputPath either does not exist or is not accessible."
            }
            ElseIf (($OutputPath | Test-Path) -and (-Not($OutputPath | Test-Path -PathType 'Container' -ErrorAction SilentlyContinue))) {
                Throw "-OutputPath must point to a directory."
            }
        }
        Catch {
            Write-Host "$($_.Exception.Message)" -ForegroundColor Red
            Exit 1
        }
    }

    # Set initial variables
    $Global:LogComponent = "Evaluate-STIG $($ESVersion)"
    $Global:ESVersion = $EvaluateStigVersion

    # If -AFPath not specified, set default
    If (-Not($AFPath)) {
        $AFPath = (Join-Path -Path $PsScriptRoot -ChildPath "AnswerFiles")
    }

    If ($host.privatedata) {
        Try {
            # Set Progress Bar Colors
            $host.privatedata.ProgressForegroundColor = "White"

            Switch ($ScanType) {
                "Unclassified" {
                    $host.privatedata.ProgressBackgroundColor = "DarkGreen"
                }
                "Classified" {
                    $host.privatedata.ProgressBackgroundColor = "DarkRed"
                }
            }
        }
        Catch {
            # Do nothing
        }
    }

    if ($Marking) {
        $Marking = $Marking.ToUpper()
    }

    If ($ComputerName) {
        #####################################################
        # Scan remote system
        #####################################################

        Try {
            If ($IsLinux) {
                Throw "Parameter -ComputerName is only supported on Windows systems."
            }

            # Set working dir for remote scans
            Switch ($OSPlatform) {
                "Windows" {
                    $RemoteScanDir = Join-Path -Path (Get-Item $env:TEMP).FullName -ChildPath "Evaluate-STIG"
                }
                "Linux" {
                    $RemoteScanDir = "/tmp/Evaluate-STIG"
                }
            }
            $RemoteWorkingDir = Join-Path -Path $RemoteScanDir -ChildPath "RemoteScanTemp"

            If (-Not(Test-Path $RemoteScanDir)) {
                $null = New-Item -Path $RemoteScanDir -ItemType Directory -ErrorAction Stop
            }
            If (-Not(Test-Path $RemoteWorkingDir)) {
                $null = New-Item -Path $RemoteWorkingDir -ItemType Directory -ErrorAction Stop
            }

            # Check/Create lock file
            $ProcLockInfo = Get-Content (Join-Path $RemoteWorkingDir -ChildPath Evaluate-STIG.lck) -ErrorAction SilentlyContinue
            If ($ProcLockInfo) {
                if (Get-Process -Name $ProcLockInfo.split("`r`n")[0] | Where-Object { $_.Id -eq $ProcLockInfo.split("`r`n")[1] }) {
                    Write-Host "Evaluate-STIG is currently processing remote scans from another source or was terminated unexpectedly.`r`nProcess Name : $($ProcLockInfo.split("`r`n")[0])`r`nProcess ID   : $($ProcLockInfo.split("`r`n")[1])" -ForegroundColor Red
                    Exit 2
                }
            }
            $CurrentProcess = [System.Diagnostics.Process]::GetCurrentProcess()
            Set-Content -Path (Join-Path $RemoteWorkingDir -ChildPath Evaluate-STIG.lck) -Value "$($CurrentProcess.ProcessName)`n$($CurrentProcess.ID)"

            # Get local host data
            $LocalHost = New-Object System.Collections.Generic.List[System.Object]
            $NewObj = [PSCustomObject]@{
                HostName    = ([Environment]::MachineName).ToUpper()
                IPv4Address = (Get-NetIPAddress).IPv4Address
            }
            $LocalHost.Add($NewObj)

            # If source machine is to be scanned, confirm PS is elevated or that -AltCredential is selected
            If (($ComputerName -contains "127.0.0.1") -or ($ComputerName -contains "::1") -or ($ComputerName -contains "localhost") -or ($ComputerName -match $LocalHost.HostName) -or ($LocalHost.IPv4Address | ForEach-Object {If ($_ -in $ComputerName) {
                            Return $true
                        }})) {
                If (-NOT(([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator") -or $AltCredential)) {
                    Throw "LOCALHOST to be included in scan.  You must run this from an elevated PowerShell session or use -AltCredential."
                }
            }

            # Build arguments hashtable
            $HashArguments = @{
                ComputerName      = $ComputerName
                ScanType          = $ScanType
                VulnTimeout       = $VulnTimeout
                AFPath            = $AFPath
                AnswerKey         = $AnswerKey
                ESVersion         = $ESVersion
                LogComponent      = $LogComponent
                OSPlatform        = $OSPlatform
                ES_Path           = $PsScriptRoot
                RemoteScanDir     = $RemoteScanDir
                RemoteWorkingDir  = $RemoteWorkingDir
                PowerShellVersion = $PowerShellVersion
            }
            If ($Marking) {
                $HashArguments.Add("Marking", $Marking)
            }
            If ($Output) {
                $HashArguments.Add("Output", $($Output -join ","))

                If ($Output -match @("(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$|^Summary$|^OQE$)")) {
                    $HashArguments.Add("PreviousToKeep", $PreviousToKeep)
                }

                If ("STIGManager" -in $Output) {
                    if ($SMPassphrase) {
                        $HashArguments.Add("SMPassphrase", $SMPassphrase)
                    }
                    if ($SMCollection) {
                        $HashArguments.Add("SMCollection", $SMCollection)
                    }
                }
            }
            If ($OutputPath) {
                $HashArguments.Add("OutputPath", $OutputPath)
            }
            If ($ApplyTattoo) {
                $HashArguments.Add("ApplyTattoo", $true)
            }
            If ($AllowDeprecated) {
                $HashArguments.Add("AllowDeprecated", $true)
            }
            If ($SelectSTIG) {
                $HashArguments.Add("SelectSTIG", $SelectSTIG)
            }
            If ($SelectVuln) {
                $HashArguments.Add("SelectVuln", $SelectVuln)
            }
            If ($ExcludeSTIG) {
                $HashArguments.Add("ExcludeSTIG", $ExcludeSTIG)
            }
            If ($ExcludeVuln) {
                $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
            }
            If ($ForceSTIG) {
                $HashArguments.Add("ForceSTIG", $ForceSTIG)
            }
            If ($AltCredential) {
                $HashArguments.Add("AltCredential", $true)
            }
            If ($ThrottleLimit) {
                $HashArguments.Add("ThrottleLimit", $ThrottleLimit)
            }

            $ScanResult = Invoke-RemoteScan @HashArguments

            If (Test-Path $RemoteWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $RemoteWorkingDir\Evaluate-STIG.lck -Force
            }
        }
        Catch {
            Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
            If (Test-Path $RemoteWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $RemoteWorkingDir\Evaluate-STIG.lck -Force
            }

            # Remove InstalledSoftware variable if it exists
            If ($null -ne $Global:InstalledSoftware) {
                Remove-Variable -Name InstalledSoftware -Scope Global
            }

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

            Exit 1
        }
    }
    ElseIf ($CiscoConfig) {
        #####################################################
        # Scan Cisco Show Tech Files
        #####################################################

        Try {
            # Set working dir for Cisco scans
            Switch ($OSPlatform) {
                "Windows" {
                    $CiscoScanDir = Join-Path -Path (Get-Item $env:TEMP).FullName -ChildPath "Evaluate-STIG"
                }
                "Linux" {
                    $CiscoScanDir = "/tmp/Evaluate-STIG"
                }
            }
            $CiscoWorkingDir = Join-Path -Path $CiscoScanDir -ChildPath "CiscoScanTemp"

            If (-Not(Test-Path $CiscoScanDir)) {
                $null = New-Item -Path $CiscoScanDir -ItemType Directory -ErrorAction Stop
            }
            If (-Not(Test-Path $CiscoWorkingDir)) {
                $null = New-Item -Path $CiscoWorkingDir -ItemType Directory -ErrorAction Stop
            }

            # Import required modules
            If ($PowerShellVersion -lt [Version]"7.0") {
                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Cisco_Functions") -ErrorAction Stop
            }
            Else {
                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Cisco_Functions") -SkipEditionCheck -ErrorAction Stop
            }

            If (Test-Path $CiscoConfig -ErrorAction Stop) {
                # Test OutputPath connectivity
                If ($OutputPath -and -Not(Test-Path $OutputPath)) {
                    Throw "$OutputPath is not accessible by $([Environment]::Username) on $MachineName."
                }

                # Check/Create lock file
                $ProcLockInfo = Get-Content (Join-Path $CiscoWorkingDir -ChildPath Evaluate-STIG.lck) -ErrorAction SilentlyContinue
                If ($ProcLockInfo) {
                    if (Get-Process -Name $ProcLockInfo.split("`r`n")[0] | Where-Object { $_.Id -eq $ProcLockInfo.split("`r`n")[1] }) {
                        Write-Host "Evaluate-STIG is currently processing Cisco scans from another source or was terminated unexpectedly.`r`nProcess Name : $($ProcLockInfo.split("`r`n")[0])`r`nProcess ID   : $($ProcLockInfo.split("`r`n")[1])" -ForegroundColor Red
                        Exit 2
                    }
                }
                $CurrentProcess = [System.Diagnostics.Process]::GetCurrentProcess()
                Set-Content -Path (Join-Path $CiscoWorkingDir -ChildPath Evaluate-STIG.lck) -Value "$($CurrentProcess.ProcessName)`n$($CurrentProcess.ID)"

                # Build arguments hashtable
                $HashArguments = @{
                    CiscoConfig       = $CiscoConfig
                    ScanType          = $ScanType
                    VulnTimeout       = $VulnTimeout
                    AFPath            = $AFPath
                    AnswerKey         = $AnswerKey
                    ESVersion         = $ESVersion
                    LogComponent      = $LogComponent
                    OSPlatform        = $OSPlatform
                    ES_Path           = $PsScriptRoot
                    PowerShellVersion = $PowerShellVersion
                    CiscoScanDir      = $CiscoScanDir
                    CiscoWorkingDir   = $CiscoWorkingDir
                }
                If ($Marking) {
                    $HashArguments.Add("Marking", $Marking)
                }
                If ($Output) {
                    $HashArguments.Add("Output", $Output)

                    If ($Output -match @("(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$|^Summary$|^OQE$)")) {
                        $HashArguments.Add("PreviousToKeep", $PreviousToKeep)
                    }

                    If ("STIGManager" -in $Output) {
                        if ($SMPassphrase){
                            $HashArguments.Add("SMPassphrase", $SMPassphrase)
                        }
                        if ($SMCollection){
                            $HashArguments.Add("SMCollection", $SMCollection)
                        }
                    }
                }
                If ($OutputPath) {
                    $HashArguments.Add("OutputPath", $OutputPath)
                }
                If ($AllowDeprecated) {
                    $HashArguments.Add("AllowDeprecated", $true)
                }
                If ($SelectSTIG) {
                    $HashArguments.Add("SelectSTIG", $SelectSTIG)
                }
                If ($SelectVuln) {
                    $HashArguments.Add("SelectVuln", $SelectVuln)
                }
                If ($ExcludeSTIG) {
                    $HashArguments.Add("ExcludeSTIG", $ExcludeSTIG)
                }
                If ($ExcludeVuln) {
                    $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
                }
                If ($ForceSTIG) {
                    $HashArguments.Add("ForceSTIG", $ForceSTIG)
                }
                If ($ThrottleLimit) {
                    $HashArguments.Add("ThrottleLimit", $ThrottleLimit)
                }

                $ScanResult = Invoke-ConfigFileScan @HashArguments
            }
            Else {
                Throw "Cannot find path '$CiscoConfig' because it does not exist."
            }
            If (Test-Path $CiscoWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $CiscoWorkingDir\Evaluate-STIG.lck -Force
            }
        }
        Catch {
            Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
            If (Test-Path $CiscoWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $CiscoWorkingDir\Evaluate-STIG.lck -Force
            }

            # Remove InstalledSoftware variable if it exists
            If ($null -ne $Global:InstalledSoftware) {
                Remove-Variable -Name InstalledSoftware -Scope Global
            }

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

            Exit 1
        }
    }
    ElseIf ($VCenterApplianceName -or $VMName) {
        # TODO: THIS IS PRE-STAGING. NOT IN USE AT THIS TIME.
        #####################################################
        # Scan VCenter Appliance or VM
        #####################################################
        # TODO: Confirm if PowerCLI works w/ 5.2 AND 7.X. If ONLY 5.2 is useable remove any references to Linux.
            # both 5.2 and 7.X seem to support PowerCLI. Need to test PowerCLI + Linux
            # https://www.vgemba.net/vmware/PowerShell-PowerCLI-Part-1/
            # PowerCLI seems to support Linux
            # https://developer.vmware.com/docs/17472/-compatibility-matrix
        # TODO: Test if a process lock is required.

        Try {
            # Set working dir for VCenter Scans
            Switch ($OSPlatform) {
                "Windows" {
                    $VCenterScanDir = Join-Path -Path (Get-Item $env:TEMP).FullName -ChildPath "Evaluate-STIG"
                }
                "Linux" {
                    $VCenterScanDir = "/tmp/Evaluate-STIG"
                }
            }
            $VCenterWorkingDir = Join-Path -Path $VCenterScanDir -ChildPath "VCenterScanTemp"

            If (-Not(Test-Path $VCenterScanDir)) {
                $null = New-Item -Path $VCenterScanDir -ItemType Directory -ErrorAction Stop
            }
            If (-Not(Test-Path $VCenterWorkingDir)) {
                $null = New-Item -Path $VCenterWorkingDir -ItemType Directory -ErrorAction Stop
            }

            # Ensure required modules are available
            $AvailableModules = (Get-Module -ListAvailable -All).Name
            If ("VMWare.PowerCLI" -notin $AvailableModules) {
                # TODO: Error out unable to process because module is missing.
                Write-Host "ERROR: 'VMWare.PowerCLI' module is NOT available to PowerShell. VMWare checklists will NOT be generated." -ForegroundColor Red
                break
            }
            Remove-Variable -Name 'AvailableModules'

            # Import required modules
            If ($PowerShellVersion -lt [Version]"7.0") {
                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" |
                    Join-Path -ChildPath "VMWare_Functions") -ErrorAction Stop
            }
            Else {
                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" |
                    Join-Path -ChildPath "VMWare_Functions") -SkipEditionCheck -ErrorAction Stop
            }

            # Build arguments hashtable
            $HashArguments = @{
                # Standard Arguments
                ScanType          = $ScanType
                VulnTimeout       = $VulnTimeout
                AFPath            = $AFPath
                AnswerKey         = $AnswerKey
                PreviousToKeep    = $PreviousToKeep
                ESVersion         = $ESVersion
                LogComponent      = $LogComponent
                OSPlatform        = $OSPlatform
                ES_Path           = $PsScriptRoot
                PowerShellVersion = $PowerShellVersion
                # Custom Arugments
                VCenterApplianceName = $($VCenterApplianceName)
                VCenterScanDir       = $($VCenterScanDir)
                VCenterWorkingDir    = $($VCenterWorkingDir)
            }
            # Standard Arguments
            If ($Marking) {
                $HashArguments.Add("Marking", $Marking)
            }
            If ($Output) {
                $HashArguments.Add("Output", $Output)

                If ($Output -match @("(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$|^Summary$|^OQE$)")) {
                    $HashArguments.Add("PreviousToKeep", $PreviousToKeep)
                }

                If ("STIGManager" -in $Output) {
                    if ($SMPassphrase){
                        $HashArguments.Add("SMPassphrase", $SMPassphrase)
                    }
                    if ($SMCollection){
                        $HashArguments.Add("SMCollection", $SMCollection)
                    }
                }
            }
            If ($OutputPath) {
                $HashArguments.Add("OutputPath", $OutputPath)
            }
            If ($AllowDeprecated) {
                $HashArguments.Add("AllowDeprecated", $true)
            }
            If ($SelectSTIG) {
                $HashArguments.Add("SelectSTIG", $SelectSTIG)
            }
            If ($SelectVuln) {
                $HashArguments.Add("SelectVuln", $SelectVuln)
            }
            If ($ExcludeSTIG) {
                $HashArguments.Add("ExcludeSTIG", $ExcludeSTIG)
            }
            If ($ExcludeVuln) {
                $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
            }
            If ($ForceSTIG) {
                $HashArguments.Add("ForceSTIG", $ForceSTIG)
            }
            If ($ThrottleLimit) {
                $HashArguments.Add("ThrottleLimit", $ThrottleLimit)
            }
            # Custom Arguments
            If ($VMName) {
                $HashArguments.Add('VMName', $VMName)
            }

            # TODO: Add lock if it is going in here.

            # TODO: Uncomment this line when ready.
            #$ScanOutput = Invoke-VCenterQuery @HashArguments

            If (Test-Path $VCenterWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $VCenterWorkingDir\Evaluate-STIG.lck -Force
            }
        }
        Catch {
            Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
            If (Test-Path $VCenterWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $VCenterWorkingDir\Evaluate-STIG.lck -Force
            }

            # Remove InstalledSoftware variable if it exists
            If ($null -ne $Global:InstalledSoftware) {
                Remove-Variable -Name InstalledSoftware -Scope Global
            }

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

            Exit 1
        }
    }
    Else {
        #####################################################
        # Scan local system
        #####################################################
        $Global:ScanStartDate = (Get-Date -Format "MM/dd/yyyy")

        # OS dependent prerequiste checks
        Switch ($OSPlatform) {
            "Windows" {
                Try {
                    # Confirm we have an elevated session.
                    If (-NOT([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator") -and !$AltCredential -and ($LinuxList.count -eq 0)) {
                        Throw "You must run this from an elevated PowerShell session or use -AltCredential."
                    }

                    # Check Windows version.  Windows version 6.1 or greater required.
                    # https://docs.microsoft.com/en-us/windows/win32/sysinfo/operating-system-version
                    If ([Version](Get-CimInstance Win32_OperatingSystem).Version -lt "6.1") {
                        Throw "$((Get-CimInstance Win32_OperatingSystem).Version) is not supported.  Must be version 6.1 or greater.  Cannot continue."
                    }

                    # Confirm native PowerShell session
                    $OSArch = (Get-ItemProperty 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name PROCESSOR_ARCHITECTURE).PROCESSOR_ARCHITECTURE
                    If ($OSArch -eq "AMD64") {
                        If ([IntPtr]::Size -ne "8") {
                            Throw "32-Bit PowerShell session detected.  Evaluate-STIG must be ran in 64-Bit PowerShell on 64-Bit systems."
                        }
                    }
                }
                Catch {
                    Write-Host "$($_.Exception.Message)" -ForegroundColor Red
                    Exit 1
                }
            }
            "Linux" {
                Try {
                    # Confirm we have an elevated session.
                    If ((id -u) -ne 0) {
                        Throw "You must run this from an elevated PowerShell session."
                    }
                }
                Catch {
                    Write-Host "$($_.Exception.Message)" -ForegroundColor Red
                    Exit 1
                }

                # Check for prerequisites
                Try {
                    $null = lshw -version 2>/dev/null
                }
                Catch {
                    Write-Host "'lshw' is required to be installed." -ForegroundColor Red
                    Exit 1
                }

                if ($ComputerName) {
                    Write-Host "Remote computer option supports Windows only." -ForegroundColor Red
                    Exit 1
                }
            }
        }

        # Test OutputPath connectivity
        If ($OutputPath -and -Not(Test-Path $OutputPath)) {
            Write-Host "$OutputPath is not accessible by $([Environment]::Username) on $MachineName." -ForegroundColor Red
            Exit 1
        }

        # Set variables
        Switch ($OSPlatform) {
            "Windows" {
                $Global:WorkingDir = "$env:windir\Temp\Evaluate-STIG"
                $DomainRole = (Get-CimInstance Win32_ComputerSystem).DomainRole
                $HiveFile = "$($WorkingDir)\Eval-STIG_UserHive.dat" # Copy of user's registry hive
                $ES_Hive_Tasks = @("Eval-STIG_SaveHive", "Eval-STIG_LoadHive", "Eval-STIG_UnloadHive") # Potential scheduled tasks for user hive actions
            }
            "Linux" {
                $Global:WorkingDir = "/tmp/Evaluate-STIG"
                $Release = Get-Content /etc/os-release
                If ($release | Select-String "Workstation") {
                    $DomainRole = 1
                }
                ElseIf ($release | Select-String "Server") {
                    $DomainRole = 3
                }
                Else {
                    $DomainRole = 1
                }
            }
        }
        $MachineName = ([Environment]::MachineName).ToUpper()
        If ($OutputPath) {
            If ($SelectVuln) {
                $Global:ResultsPath = Join-Path -Path $OutputPath -ChildPath "_Partial_$MachineName"
            }
            Else {
                $Global:ResultsPath = Join-Path -Path $OutputPath -ChildPath $MachineName
            }
        }
        $StartTime = Get-Date
        $Date = Get-Date -Format yyyyMMdd
        $Global:STIGLog = Join-Path -Path $WorkingDir -ChildPath "Evaluate-STIG.log"
        [int]$Global:TotalMainSteps = 1
        [int]$Global:CurrentMainStep = 1
        [int]$Global:ProgressId = 1
        if ($Marking) {
            $Global:ProgressActivity = "Evaluate-STIG (Version: $ESVersion | Scan Type: $ScanType | Marking: $Marking | Answer Key: $AnswerKey)"
        }
        else {
            $Global:ProgressActivity = "Evaluate-STIG (Version: $ESVersion | Scan Type: $ScanType | Answer Key: $AnswerKey)"
        }

        # Create WorkingDir
        If (-Not(Test-Path $WorkingDir)) {
            $null = New-Item $WorkingDir -ItemType Directory
        }

        # Check/Create lock file
        $ProcLockInfo = Get-Content (Join-Path $WorkingDir -ChildPath Evaluate-STIG.lck) -ErrorAction SilentlyContinue
        If ($ProcLockInfo) {
            if (Get-Process -Name $ProcLockInfo.split("`r`n")[0] | Where-Object { $_.Id -eq $ProcLockInfo.split("`r`n")[1] }) {
                Write-Host "Evaluate-STIG is currently processing from another source or was terminated unexpectedly.`r`nProcess Name : $($ProcLockInfo.split("`r`n")[0])`r`nProcess ID   : $($ProcLockInfo.split("`r`n")[1])" -ForegroundColor Red
                Exit 2
            }
        }
        $CurrentProcess = [System.Diagnostics.Process]::GetCurrentProcess()
        Set-Content -Path (Join-Path $WorkingDir -ChildPath Evaluate-STIG.lck) -Value "$($CurrentProcess.ProcessName)`n$($CurrentProcess.ID)"

        Try {
            # ++++++++++++++++++++++ Begin processing ++++++++++++++++++++++
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Initializing and generating list of required STIGs"

            If (Test-Path $STIGLog) {
                Remove-Item $STIGLog -Force
            }

            If ($Marking) {
                Write-Log -Path $STIGLog -Message "                                                                                          $Marking                                                                                          " -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }

            Write-Log -Path $STIGLog -Message "Begin Local Logging" -TemplateMessage LineBreak-Text -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            if ($SMPassphrase){
                Write-Log -Path $STIGLog -Message "Executing: $(($MyInvocation.Line).Replace((($MyInvocation.Line).split("-") | Where-Object {$_ -match "Passphrase"}),'SMPassphrase ************** '))" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }
            else{
                Write-Log -Path $STIGLog -Message "Executing: $($MyInvocation.Line)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }
            $InUsePrefs | Foreach-Object {
                Write-Log -Path $STIGLog -Message "Utilizing Preference: $($_) $($Preferences.Preferences.EvaluateSTIG.$_)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }
            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Verify Evaluate-STIG files integrity
            $Verified = $true
            $XccdfFailedHash = @()
            Write-Log -Path $STIGLog -Message "Verifying Evaluate-STIG file integrity" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            If (Test-Path (Join-Path -Path $PSScriptRoot -ChildPath "xml" | Join-Path -ChildPath "FileList.xml")) {
                [XML]$FileListXML = Get-Content -Path (Join-Path -Path $PSScriptRoot -ChildPath "xml" | Join-Path -ChildPath "FileList.xml")
                If ((Test-XmlSignature -checkxml $FileListXML -Force) -ne $true) {
                    Write-Log -Path $STIGLog -Message "ERROR: 'FileList.xml' failed authenticity check.  Unable to verify content integrity." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                }
                Else {
                    ForEach ($File in $FileListXML.FileList.File) {
                        $Path = (Join-Path -Path $PsScriptRoot -ChildPath $File.Path | Join-Path -ChildPath $File.Name)
                        If (Test-Path $Path) {
                            If ((Get-FileHash -Path $Path -Algorithm SHA256).Hash -ne $File.SHA256Hash) {
                                $Verified = $false
                                If ($File.Name -like "*xccdf.xml") {
                                    $XccdfFailedHash += $File.Name
                                }
                                Write-Log -Path $STIGLog -Message "WARNING: '$($Path)' failed integrity check." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            }
                        }
                        Else {
                            If ($File.ScanReq -eq "Required") {
                                $Verified = $false
                                Write-Log -Path $STIGLog -Message "ERROR: '$($File.Name)' is a required file but not found.  Scan results may be incomplete." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            }
                        }
                    }
                    If ($Verified -eq $true) {
                        Write-Log -Path $STIGLog -Message "Evaluate-STIG file integrity check passed." -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    }
                    Else {
                        Write-Log -Path $STIGLog -Message "WARNING: One or more Evaluate-STIG files failed integrity check." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                    }
                }
            }
            Else {
                Throw [PSCustomObject]@{ExitCode = 1; Message = "'FileList.xml' not found."}
            }

            # Schema Files
            $STIGList_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_STIGList.xsd"
            $AnswerFile_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_AnswerFile.xsd"
            $Checklist_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "U_Checklist_Schema_V2.xsd"
            $Checklist_json = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "CKLB.schema.json"
            If (-Not(Test-Path $STIGList_xsd)) {
                Throw [PSCustomObject]@{ExitCode = 1; Message = "'$STIGList_xsd' - file not found."}
            }
            ElseIf (-Not(Test-Path $AnswerFile_xsd)) {
                Throw [PSCustomObject]@{ExitCode = 1; Message = "'$AnswerFile_xsd' - file not found."}
            }
            ElseIf (-Not(Test-Path $Checklist_xsd)) {
                Throw [PSCustomObject]@{ExitCode = 1; Message = "'$Checklist_xsd' - file not found."}
            }
            ElseIf (-Not(Test-Path $Checklist_json)) {
                Throw [PSCustomObject]@{ExitCode = 1; Message = "'$Checklist_json' - file not found."}
            }

            # STIGList.xml validation
            $XmlFile = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (-Not(Test-Path $XmlFile)) {
                Throw [PSCustomObject]@{ExitCode = 1; Message = "'$XmlFile' - file not found."}
            }
            Else {
                $Result = Test-XmlValidation -XmlFile $XmlFile -SchemaFile $STIGList_xsd
                If ($Result -ne $true) {
                    ForEach ($Item in $Result.Message) {
                        Write-Log -Path $STIGLog -Message $Item -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    }
                    Throw [PSCustomObject]@{ExitCode = 1; Message = "'$($XmlFile)' failed XML validation"}
                }
            }

            Write-Log -Path $STIGLog -Message "Evaluate-STIG Version: $ESVersion" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Launching User: $([Environment]::Username)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Pre-checks passed.  Begin processing.
            # =====================================
            # Write configuration data to log
            Write-Log -Path $STIGLog -Message "Hostname: $MachineName" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Switch ($DomainRole) {
                0 {
                    Write-Log -Path $STIGLog -Message "Domain Role: Standalone Workstation" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                } # Standalone Workstation (0)
                1 {
                    Write-Log -Path $STIGLog -Message "Domain Role: Member Workstation" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                } # Member Workstation (1)
                2 {
                    Write-Log -Path $STIGLog -Message "Domain Role: Standalone Server" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                } # Standalone Server (2)
                3 {
                    Write-Log -Path $STIGLog -Message "Domain Role: Member Server" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                } # Member Server (3)
                4 {
                    Write-Log -Path $STIGLog -Message "Domain Role: Backup Domain Controller" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                } # Backup DC (4)
                5 {
                    Write-Log -Path $STIGLog -Message "Domain Role: Primary Domain Controller" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                } # Primary DC (4)
                Default {
                    Write-Log -Path $STIGLog -Message "Domain Role: Unknown" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                }
            }
            Write-Log -Path $STIGLog -Message "OS Platform: $OSPlatform" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "PS Version: $PowerShellVersion" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Scan Type: $ScanType" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Answer Key: $AnswerKey" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Answer File Path: $AFPath" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Results Path: $ResultsPath" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # --- Begin Answer File validation
            Write-Log -Path $STIGLog -Message "Validating answer files" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            $AnswerFileList = New-Object System.Collections.Generic.List[System.Object]
            $XmlFiles = Get-ChildItem -Path $AFPath | Where-Object Extension -EQ ".xml"

            # Verify answer files for proper format
            ForEach ($Item in $XmlFiles) {
                $Validation = (Test-XmlValidation -XmlFile $Item.FullName -SchemaFile $AnswerFile_xsd)
                If ($Validation -eq $true) {
                    Write-Log -Path $STIGLog -Message "$($Item.Name) : Passed" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    [XML]$Content = Get-Content $Item.FullName
                    If ($Content.STIGComments.Name) {
                        $NewObj = [PSCustomObject]@{
                            STIG          = $Content.STIGComments.Name
                            Name          = $Item.Name
                            FullName      = $Item.FullName
                            LastWriteTime = $Item.LastWriteTime
                        }
                        $AnswerFileList.Add($NewObj)
                    }
                }
                Else {
                    Write-Log -Path $STIGLog -Message "ERROR: $($Item.Name) : Answer file failed schema validation and will be ignored.  Please correct or remove." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    Write-Log -Path $STIGLog -Message "$($Validation.Message)" -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                }
            }

            $AnswerFileList = $AnswerFileList | Sort-Object LastWriteTime -Descending
            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            # --- End Answer File validation

            # Build list of required STIGs
            Write-Log -Path $STIGLog -Message "Gathering list of STIGs applicable to this sytem" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            [XML]$STIGList = Get-Content (Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml")
            $STIGsToProcess = New-Object System.Collections.Generic.List[System.Object]
            If ($SelectSTIG) {
                ForEach ($Node in $STIGList.List.STIG) {
                    If ($Node.StigContent -in $XccdfFailedHash) {
                        Write-Log -Path $STIGLog -Message "ERROR: $($Node.StigContent) : Failed hash check. This STIG will not be scanned." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    }
                    ElseIf ($Node.Shortname -in $SelectSTIG) {
                        If ($Node.DetectionCode -and (Invoke-Expression $Node.DetectionCode) -eq $true) {
                            If ((Test-STIGDependencyFiles -RootPath $PSScriptRoot -STIGData $Node -LogPath $STIGLog -OSPlatform $OSPlatform) -eq $true) {
                                If ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName -or $_.STIG -eq $Node.Name)}) {
                                    $AFtoUse = ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName -or $_.STIG -eq $Node.Name)})[0]
                                }
                                Else {
                                    $AFtoUse = ""
                                }
                                $NewObj = [PSCustomObject]@{
                                    Name           = $Node.Name
                                    Shortname      = $Node.ShortName
                                    StigContent    = $Node.StigContent
                                    AnswerFile     = $AFtoUse
                                    PsModule       = $Node.PsModule
                                    PsModuleVer    = $Node.PsModuleVer
                                    UserSettings   = $Node.UserSettings
                                    CanCombine     = $Node.CanCombine
                                    Classification = $Node.Classification
                                    Deprecated     = [System.Convert]::ToBoolean($Node.Deprecated)
                                    Forced         = $false
                                }
                                $STIGsToProcess.Add($NewObj)
                            }
                        }
                        ElseIf ($Node.Shortname -notin $ForceSTIG) {
                            Write-Log -Path $STIGLog -Message "WARNING: Scan for '$($Node.Name)' requested with -SelectSTIG but is not applicable to this system so will be ignored." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        }
                    }
                }
            }
            Else {
                ForEach ($Node in $STIGList.List.STIG) {
                    If ($Node.Deprecated -eq "true" -and -Not($AllowDeprecated)) {
                        # Ignore deprecated STIG
                    }
                    Else {
                        If ($Node.StigContent -in $XccdfFailedHash) {
                            Write-Log -Path $STIGLog -Message "ERROR: $($Node.StigContent) : Failed hash check. This STIG will not be scanned." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                        ElseIf ($Node.DetectionCode -and (Invoke-Expression $Node.DetectionCode) -eq $true) {
                            If ($Node.Shortname -in $ExcludeSTIG -and $Node.Shortname -notin $ForceSTIG) {
                                Write-Log -Path $STIGLog -Message "WARNING: '$($Node.Name)' is applicable to this system but has been excluded from scan with the -ExcludeSTIG option." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            }
                            Else {
                                If ((Test-STIGDependencyFiles -RootPath $PSScriptRoot -STIGData $Node -LogPath $STIGLog -OSPlatform $OSPlatform) -eq $true) {
                                    If ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName -or $_.STIG -eq $Node.Name)}) {
                                        $AFtoUse = ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName -or $_.STIG -eq $Node.Name)})[0]
                                    }
                                    Else {
                                        $AFtoUse = ""
                                    }
                                    $NewObj = [PSCustomObject]@{
                                        Name           = $Node.Name
                                        Shortname      = $Node.ShortName
                                        StigContent    = $Node.StigContent
                                        AnswerFile     = $AFtoUse
                                        PsModule       = $Node.PsModule
                                        PsModuleVer    = $Node.PsModuleVer
                                        UserSettings   = $Node.UserSettings
                                        CanCombine     = $Node.CanCombine
                                        Classification = $Node.Classification
                                        Deprecated     = [System.Convert]::ToBoolean($Node.Deprecated)
                                        Forced         = $false
                                    }
                                    $STIGsToProcess.Add($NewObj)
                                }
                            }
                        }
                    }
                }
            }

            # Add any forced STIGs to scan
            If ($ForceSTIG) {
                ForEach ($STIG in $ForceSTIG) {
                    If ($STIG -notin $STIGsToProcess.ShortName) {
                        $Node = $STIGList.List.STIG | Where-Object ShortName -eq $STIG
                        If ($Node.StigContent -in $XccdfFailedHash) {
                            # Do nothing. We've already warned on bad file hash.
                        }
                        Else {
                            If ($Node.DetectionCode -and (Invoke-Expression $Node.DetectionCode) -ne $true) {
                                $Forced = $true
                                Write-Log -Path $STIGLog -Message "WARNING: Scan for '$($Node.Name)' forced with -ForceSTIG.  Evaluate-STIG results are not guaranteed with this option.  Use at own risk." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            }
                            Else {
                                $Forced = $false
                            }
                            If ((Test-STIGDependencyFiles -RootPath $PSScriptRoot -STIGData $Node -LogPath $STIGLog -OSPlatform $OSPlatform) -eq $true) {
                                If ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName -or $_.STIG -eq $Node.Name)}) {
                                    $AFtoUse = ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName -or $_.STIG -eq $Node.Name)})[0]
                                }
                                Else {
                                    $AFtoUse = ""
                                }
                                $NewObj = [PSCustomObject]@{
                                    Name           = $Node.Name
                                    Shortname      = $Node.ShortName
                                    StigContent    = $Node.StigContent
                                    AnswerFile     = $AFtoUse
                                    PsModule       = $Node.PsModule
                                    PsModuleVer    = $Node.PsModuleVer
                                    UserSettings   = $Node.UserSettings
                                    CanCombine     = $Node.CanCombine
                                    Classification = $Node.Classification
                                    Deprecated     = [System.Convert]::ToBoolean($Node.Deprecated)
                                    Forced         = $Forced
                                }
                                $STIGsToProcess.Add($NewObj)
                            }
                        }
                    }
                }
            }
            $STIGsToProcess = $STIGsToProcess | Sort-Object Name
            [int]$TotalMainSteps = $TotalMainSteps + ($STIGsToProcess | Measure-Object).Count

            # Write list of STIGs that will be evaluated to log
            Write-Log -Path $STIGLog -Message "The following STIGs will be evaluated:" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            ForEach ($STIG in $STIGsToProcess) {
                If ($STIG.Deprecated -eq $true) {
                    Write-Log -Path $STIGLog -Message "STIG: $($STIG.Name) [Deprecated]  |  AnswerFile: $($STIG.AnswerFile.Name)" -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                }
                Else {
                    Write-Log -Path $STIGLog -Message "STIG: $($STIG.Name)  |  AnswerFile: $($STIG.AnswerFile.Name)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                }
            }
            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Confirm STIG specific prerequisites are met
            If (($STIGsToProcess.Name -like "Microsoft SQL Server*") -or ($STIGsToProcess.Name -like "IIS *")) {
                $AvailModules = (Get-Module -ListAvailable -All).Name
                # IIS
                If ($STIGsToProcess.Name -like "IIS *") {
                    If ("WebAdministration" -notin $AvailModules) {
                        Write-Log -Path $STIGLog -Message "ERROR: 'WebAdministration' module is not available to PowerShell. IIS checklists will not be generated." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        $STIGsToIgnore = $STIGsToProcess | Where-Object Name -Like "IIS *"
                        ForEach ($Obj in $STIGsToIgnore) {
                            [Void]$STIGsToProcess.Remove($Obj)
                        }
                    }
                }

                # SQL Server
                If ($STIGsToProcess.Name -like "Microsoft SQL Server*") {
                    If (Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue) {
                        $SQLCommand = (Get-Command Invoke-Sqlcmd)
                        Write-Log -Path $STIGLog -Message "Using Module: $($SQLCommand.Source) ($($SQLCommand.Version))" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    }
                    Else {
                        Try {
                            $ImportedModules = Get-Module
                            If ("SqlServer" -notin $AvailModules -and "SQLPS" -notin $AvailModules) {
                                Throw "ERROR: Neither 'SQLPS' nor 'SqlServer' modules is are available to PowerShell.  At least one must be installed.  SQL checklists will not be generated."
                            }
                            ElseIf ("SqlServer" -in $AvailModules) {
                                If (-Not($ImportedModules | Where-Object Name -EQ "SqlServer")) {
                                    Try {
                                        Write-Log -Path $STIGLog -Message "Importing module: SqlServer" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                        (Get-Module -ListAvailable | Where-Object Name -EQ "SqlServer" | Sort-Object Version -Descending)[0] | Import-Module -WarningAction SilentlyContinue -ErrorAction Stop
                                    }
                                    Catch {
                                        Write-Log -Path $STIGLog -Message "ERROR: Failed to import 'SqlServer' module. SQL checklists will not be generated." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                        If (Get-Module | Where-Object Name -EQ "SqlServer") {
                                            Remove-Module SqlServer -ErrorAction SilentlyContinue
                                        }
                                        Throw $_
                                    }
                                }
                                Else {
                                    $SQLModule = $ImportedModules | Where-Object Name -EQ "SqlServer"
                                    Write-Log -Path $STIGLog -Message "Module: $($SQLModule.Name) ($($SQLModule.Version)) already imported" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                }
                            }
                            Else {
                                If (-Not($ImportedModules | Where-Object Name -EQ "SQLPS")) {
                                    Try {
                                        Write-Log -Path $STIGLog -Message "Importing module: SQLPS" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                        (Get-Module -ListAvailable | Where-Object Name -EQ "SQLPS" | Sort-Object Version -Descending)[0] | Import-Module -WarningAction SilentlyContinue -ErrorAction Stop
                                    }
                                    Catch {
                                        Write-Log -Path $STIGLog -Message "ERROR: Failed to import 'SQLPS' module. SQL checklists will not be generated." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                        If (Get-Module | Where-Object Name -EQ "SQLPS") {
                                            Remove-Module SQLPS -ErrorAction SilentlyContinue
                                        }
                                        Throw $_
                                    }
                                }
                                Else {
                                    $SQLModule = $ImportedModules | Where-Object Name -EQ "SQLPS"
                                    Write-Log -Path $STIGLog -Message "Module: $($SQLModule.Name) ($($SQLModule.Version)) already imported" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                }
                            }
                        }
                        Catch {
                            Write-Log -Path $STIGLog -Message $_.Exception.Message -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            $STIGsToIgnore = $STIGsToProcess | Where-Object Name -Like "Microsoft SQL Server*"
                            ForEach ($Obj in $STIGsToIgnore) {
                                [Void]$STIGsToProcess.Remove($Obj)
                            }
                        }
                    }
                }
            }

            # If no supported STIGs are applicable, log it and continue
            If (($STIGsToProcess | Measure-Object).Count -eq 0) {
                Write-Log -Path $STIGLog -Message "WARNING: No Evaluate-STIG supported STIGs are applicable to this system." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform

                # Clean up
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                Invoke-ScanCleanup -WorkingDir $WorkingDir -Logpath $STIGLog -OSPlatform $OSPlatform -LogComponent $LogComponent
                Write-Log -Path $STIGLog -Message "End Local Logging" -TemplateMessage LineBreak-Text -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

                # Complete progress bar
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -Completed

                # Remove Evaluate-STIG modules from memory
                Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

                # Exit with code
                Exit $ExitCode
            }
            Else {
                Write-Log -Path $STIGLog -Message "STIGs to process - $(($STIGsToProcess | Measure-Object).count)" -WriteOutToStream -FGColor Magenta -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }

            # Test connectivity to OutputPath and create folder for computer
            Try {
                If ($Output -match @("(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$|^Summary$|^OQE$)")) {
                    If (-Not(Test-Path $ResultsPath)) {
                        $null = New-Item $ResultsPath -ItemType Directory -ErrorAction Stop
                        Start-Sleep 5
                    }
                }
            }
            Catch {
                Write-Log -Path $STIGLog -Message "ERROR: Failed to create output path $ResultsPath)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                Throw $_
            }

            # Remove orphaned objects
            Write-Log -Path $STIGLog -Message "Checking for and removing orphaned objects from a previous scan" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Switch ($OSPlatform) {
                "Windows" {
                    # Remove existing Evaluate-STIG_UserHive in case it exists
                    If (Test-Path Registry::HKU\Evaluate-STIG_UserHive) {
                        [System.GC]::Collect()
                        Try {
                            Start-Sleep -Seconds 5
                            Write-Log -Path $STIGLog -Message "Removing orphaned object: HKU:\Evaluate-STIG_UserHive" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            $Result = Start-Process -FilePath REG -ArgumentList "UNLOAD HKU\Evaluate-STIG_UserHive" -Wait -PassThru -WindowStyle Hidden
                            If ($Result.ExitCode -ne 0) {
                                Throw # and attempt as SYSTEM
                            }
                        }
                        Catch {
                            # REG command failed so attempt to do as SYSTEM
                            Write-Log -Path $STIGLog -Message "WARNING: Failed to unload hive.  Trying as SYSTEM." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            Try {
                                $Result = Invoke-TaskAsSYSTEM -TaskName $ES_Hive_Tasks[2] -FilePath REG -ArgumentList "UNLOAD HKU\Evaluate-STIG_UserHive" -MaxRunInMinutes 1
                                If ($Result.LastTaskResult -ne 0) {
                                    Throw # and exit
                                }
                            }
                            Catch {
                                Throw [PSCustomObject]@{ExitCode = 1; Message = "Failed to unload user hive."}
                            }
                        }
                    }

                    # Remove orphaned scheduled tasks
                    If (Get-Command -Name Get-ScheduledTask -ErrorAction SilentlyContinue) {
                        $Tasks = (Get-ScheduledTask | Where-Object TaskName -In $ES_Hive_Tasks).TaskName
                        If ($Tasks) {
                            ForEach ($Item in $Tasks) {
                                Unregister-ScheduledTask -TaskName $Item -Confirm:$false -ErrorAction Stop
                            }
                        }
                    }
                    Else {
                        ForEach ($Item in $ES_Hive_Tasks) {
                            $Task = ((SCHTASKS /Query /TN $Item /V /FO List 2>$null))
                            If ($Task) {
                                $null = SCHTASKS /Delete /TN $Item /F
                            }
                        }
                    }
                }
                "Linux" {
                    # TBD
                }
            }

            $TempFiles = Get-Item -Path $WorkingDir\* -Exclude Evaluate-STIG.log, Evaluate-STIG.lck -Force
            If ($TempFiles) {
                ForEach ($Item in $TempFiles) {
                    Write-Log -Path $STIGLog -Message "Removed orphaned object: $($Item.FullName)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    $null = Remove-Item -Path $Item.FullName -Recurse -Force -ErrorAction Stop
                }
            }

            # Increase TotalMainSteps based on options/STIGs
            If ($Output -match @("(^CombinedCKL$|^CombinedCKLB$)")) {
                $TotalMainSteps++
            }

            If ($Output -match @("(^STIGManager$)")) {
                $TotalMainSteps++
            }

            If ($Output -match @("(^Summary$)")) {
                $TotalMainSteps++
            }

            If ($Output -match @("(^OQE$)")) {
                $TotalMainSteps++
            }

            If ($STIGsToProcess | Where-Object UserSettings -EQ $true) {
                $TotalMainSteps++
            }

            # OS dependent steps
            If ($OSPlatform -eq "Windows") {
                $ExtFilesRequired = $false
                ForEach ($Item in $STIGsToProcess.ShortName) {
                    If ($Item -in @("DotNET4", "Win10", "Win11", "WinServer2008R2MS", "WinServer2008R2DC", "WinServer2012DC", "WinServer2012MS", "WinServer2016", "WinServer2019", "WinServer2022", "JBoss")) {
                        $ExtFilesRequired = $true
                    }
                }
                If ($ExtFilesRequired -eq $true) {
                    $TotalMainSteps++
                }

                # =========== Determine User to Evaluate ===========
                If ($STIGsToProcess | Where-Object UserSettings -EQ $true) {
                    Write-Log -Path $STIGLog -Message "Determining which user to evaluate for HKCU items" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Determining user to evaluate and importing registry hive" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                    $CurrentMainStep++

                    # Get all profile paths and find which ntuser.pol was most recently updated.
                    $UserToProcess = Get-UsersToEval -ProvideSingleUser
                    If ($UserToProcess) {
                        Write-Log -Path $STIGLog -Message "Will evaluate $($UserToProcess.Username) for user-based settings" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message "    SID: $($UserToProcess.SID)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        If ($UserToProcess.LastPolicyUpdate -eq "Never") {
                            Write-Log -Path $STIGLog -Message "    Policy Updated: $($UserToProcess.LastPolicyUpdate)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        }
                        Else {
                            Write-Log -Path $STIGLog -Message "    Policy Updated: $($UserToProcess.LastPolicyUpdate) ($((New-TimeSpan -Start $UserToProcess.LastPolicyUpdate -End (Get-Date)).Days) days ago)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        }
                        Write-Log -Path $STIGLog -Message "    Last Used: $($UserToProcess.LastUseTime)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message "    Profile Path: $($UserToProcess.LocalPath)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    }
                    Else {
                        Write-Log -Path $STIGLog -Message "WARNING: No scannable user profile found.  Will evaluate .DEFAULT profile for user-based settings" -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        $UserToProcess = @{ }
                        $UserToProcess.UserName = ".DEFAULT"
                        $UserToProcess.SID = ".DEFAULT"
                    }

                    # =========== Export and Load User Registry Hive ===========
                    If (Test-Path -Path Registry::HKU\$($UserToProcess.SID)) {
                        # User hive is currently loaded so we must save the loaded hive as we cannot copy NTUSER.DAT due to in use.
                        Try {
                            Write-Log -Path $STIGLog -Message "User's hive is currently loaded into the registry.  Saving HKU:\$($UserToProcess.SID) to $($HiveFile)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            $Result = Start-Process -FilePath REG -ArgumentList "SAVE HKU\$($UserToProcess.SID) $($HiveFile) /y /c" -Wait -PassThru -WindowStyle Hidden
                            If ($Result.ExitCode -ne 0) {
                                Throw # and attempt as SYSTEM
                            }
                        }
                        Catch {
                            Write-Log -Path $STIGLog -Message "WARNING: Failed to save hive.  Trying as SYSTEM." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            # REG command failed so attempt to do as SYSTEM
                            Try {
                                If (Test-Path $HiveFile) {
                                    Remove-Item $HiveFile -Force
                                }
                                $Result = Invoke-TaskAsSYSTEM -TaskName $ES_Hive_Tasks[0] -FilePath REG -ArgumentList "SAVE HKU\$($UserToProcess.SID) $($HiveFile) /y /c" -MaxRunInMinutes 1
                                If ($Result.LastTaskResult -ne 0) {
                                    Throw # and exit
                                }
                            }
                            Catch {
                                Throw [PSCustomObject]@{ExitCode = 1; Message = "Failed to save user hive."}
                            }
                        }
                    }
                    Else {
                        # User hive is not currently so we we will make a copy the user's NTUSER.DAT for importing
                        Write-Log -Path $STIGLog -Message "User's hive not found in registry.  Copying $($UserToProcess.LocalPath)\NTUSER.DAT to $($HiveFile)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Copy-Item "$($UserToProcess.LocalPath)\NTUSER.DAT" -Destination $HiveFile -Force -ErrorAction Stop
                    }

                    # Load the copied/saved user hive into HKU for parsing
                    Try {
                        Write-Log -Path $STIGLog -Message "Loading $($HiveFile) into HKU:\Evaluate-STIG_UserHive" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        $Result = Start-Process -FilePath REG -ArgumentList "LOAD HKU\Evaluate-STIG_UserHive $($HiveFile)" -Wait -PassThru -WindowStyle Hidden
                        If ($Result.ExitCode -ne 0) {
                            Throw # and attempt as SYSTEM
                        }
                    }
                    Catch {
                        Write-Log -Path $STIGLog -Message "WARNING: Failed to load hive.  Trying as SYSTEM." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        # REG command failed so attempt to do as SYSTEM
                        Try {
                            $Result = Invoke-TaskAsSYSTEM -TaskName $ES_Hive_Tasks[1] -FilePath REG -ArgumentList "LOAD HKU\Evaluate-STIG_UserHive $($HiveFile)" -MaxRunInMinutes 1
                            If ($Result.LastTaskResult -ne 0) {
                                Throw # and exit
                            }
                        }
                        Catch {
                            Throw [PSCustomObject]@{ExitCode = 1; Message = "Failed to load user hive."}
                        }
                    }
                }
                Else {
                    # Set UserName and SID to "NA"
                    $UserToProcess = @{
                        UserName = "NA"
                        SID      = "NA"
                    }
                }

                # =========== Create External Reference Files ===========
                If ($ExtFilesRequired -eq $true) {
                    Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Creating temporary export files for enumeration" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                    $CurrentMainStep++

                    # AppLocker
                    ForEach ($Item in $STIGsToProcess.ShortName) {
                        If ($Item -in @("Win10", "Win11", "WinServer2008R2MS", "WinServer2008R2DC", "WinServer2012DC", "WinServer2012MS", "WinServer2016", "WinServer2019", "WinServer2022")) {
                            $AppLockerRequired = $true
                        }
                    }
                    If ($AppLockerRequired -eq $true) {
                        Try {
                            Write-Log -Path $STIGLog -Message "Collecting AppLocker effective policy and saving to $($WorkingDir)\$($AppLockerPolFile)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            $AppLockerPolFile = "AppLockerPol_$(${env:computername})_$($Date).xml"
                            If (($PsVersionTable.PSVersion -join ".") -lt [Version]"7.0") {
                                Import-Module AppLocker
                            }
                            Else {
                                Import-Module AppLocker -SkipEditionCheck
                            }
                            Get-AppLockerPolicy -Effective -Xml -ErrorAction Stop | Out-File $WorkingDir\$($AppLockerPolFile) -Force
                        }
                        Catch {
                            $AppLockerRequired = $false
                            Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                    }

                    # Security Policy
                    ForEach ($Item in $STIGsToProcess.ShortName) {
                        If ($Item -in @("Win10", "Win11", "WinServer2008R2MS", "WinServer2008R2DC", "WinServer2012DC", "WinServer2012MS", "WinServer2016", "WinServer2019", "WinServer2022", "JBoss")) {
                            $SecPolRequired = $true
                        }
                    }
                    If ($SecPolRequired -eq $true) {
                        Write-Log -Path $STIGLog -Message "Exporting security policy" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        $SecPolFileName = "Evaluate-STIG_SecPol.ini"
                        Start-Process -FilePath secedit.exe -ArgumentList "/export /cfg $($WorkingDir)\$($SecPolFileName)" -Wait -WindowStyle Hidden
                    }

                    # List of .exe.config files
                    $ConfigFileListRequired = $false
                    ForEach ($Item in $STIGsToProcess.ShortName) {
                        If ($Item -in @("DotNET4")) {
                            $ConfigFileListRequired = $true
                        }
                    }
                    If ($ConfigFileListRequired -eq $true) {
                        Try {
                            Write-Log -Path $STIGLog -Message "Collecting list of machine.config and *.exe.config files for .NET Framework 4 STIG to $($WorkingDir)\Evaluate-STIG_Net4FileList.txt" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

                            # Get .Net 4 Framework machine.config files
                            $frameworkMachineConfig = "$env:SYSTEMROOT\Microsoft.NET\Framework\v4.0.30319\Config\machine.config"
                            $framework64MachineConfig = "$env:SYSTEMROOT\Microsoft.NET\Framework64\v4.0.30319\Config\machine.config"

                            # Get hard disk drive letters
                            $WMIDisks = (Get-CimInstance Win32_LogicalDisk | Where-Object DriveType -EQ 3).DeviceID
                            $Drives = (Get-PSDrive -PSProvider FileSystem | Where-Object {$_.DisplayRoot -eq $null -and $_.Root.TrimEnd('\') -in $WMIDisks}).Root

                            # Get configuration files
                            $allConfigFiles = @()
                            $allConfigFiles += Get-ChildItem $frameworkMachineConfig
                            $allConfigFiles += Get-ChildItem $framework64MachineConfig
                            $allConfigFiles += Get-ChildItem -Recurse -LiteralPath $Drives -Filter *.exe.config -File -ErrorAction SilentlyContinue | Where-Object { ($_.FullName -NotLike "*Windows\CSC\*") -and ($_.FullName -NotLike "*Windows\WinSxS\*") }
                            $allConfigFiles.FullName | Out-File $WorkingDir\Evaluate-STIG_Net4FileList.txt -Force
                        }
                        Catch {
                            $ConfigFileListRequired = $false
                            Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                    }
                }
            }
            Else {
                # Set UserName and SID to "NA"
                $UserToProcess = @{
                    UserName = whoami
                    SID      = "NA"
                }
            }

            # =========== Run the scans ===========
            If ($Output -match @("(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$|^Summary$|^OQE$)")) {
                # $tmpResultsPath is needed for all filetype Outputs
                $tmpResultsPath = $(Join-Path -Path $WorkingDir -ChildPath "Results")
                If (-Not(Test-Path $tmpResultsPath)) {
                    $null = New-Item -Path $tmpResultsPath -ItemType Directory
                }
            }

            $ScanObjects = [System.Collections.Generic.List[System.Object]]::new()
            $ScanJobs = [System.Collections.Generic.List[System.Object]]::new()
            # Build list of jobs to be ran
            ForEach ($Item in $STIGsToProcess) {
                # Create subjobs object for STIGs that may apply multiple times (IIS, SQL, etc.)
                $SubJobs = [System.Collections.Generic.List[System.Object]]::new()

                # Temporarily import scan module for access to custom functions
                If ($PowerShellVersion -lt [Version]"7.0") {
                    Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Item.PsModule)) -ErrorAction Stop
                }
                Else {
                    Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Item.PsModule)) -SkipEditionCheck -ErrorAction Stop
                }

                # Set path to STIG .xccdf.xml and get needed data from it
                $StigXmlPath = $(Join-Path -Path $PsScriptRoot -ChildPath "StigContent" | Join-Path -ChildPath $Item.StigContent)
                $STIGID = ((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.ID).Trim()
                $STIGTitle = ((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.Title).Trim()
                $STIGVer = ((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.Version).Trim()
                $STIGRel = ((((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.'plain-text' | Where-Object { $_.id -eq "release-info" }).'#text' -split 'Benchmark')[0].Trim() -split ' ')[1].Trim()
                $STIGDate = (((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.'plain-text' | Where-Object { $_.id -eq "release-info" }).'#text' -split 'Date:')[1].Trim()
                $STIGVersion = "V$($STIGVer)R$($STIGRel)"

                $STIGTargetKey = (Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.Group[0].Rule.reference.identifier

                # Build STIGInfo Object
                $STIGInfo = [ordered]@{
                    STIGID      = $STIGID
                    Title       = $STIGTitle
                    Version     = $STIGVer
                    Release     = $STIGRel
                    ReleaseDate = $STIGDate
                }

                # Build TargetData Object
                $TargetData = Get-AssetData -OSPlatform $OSPlatform -Marking $Marking
                $TargetData.Add("Target_Key", $STIGTargetKey)
                $TargetData.Add("WebOrDatabase", $false) # Initialize 'WebOrDatabase'.  If required, set below.
                $TargetData.Add("Site", "")              # Initialize 'Site'.  If required, set below.
                $TargetData.Add("Instance", "")          # Initialize 'Instance'.  If required, set below.

                $STIGData = @{
                    StigXmlPath = $StigXmlPath
                    StigVersion = $STIGVersion
                    Name        = $Item.Name
                    ShortName   = $Item.ShortName
                    PsModule    = $Item.PsModule
                    CanCombine  = $Item.CanCombine
                }

                If ($Item.ShortName -like "IIS*") {
                    Remove-Module WebAdministration -ErrorAction SilentlyContinue
                    Import-Module WebAdministration -WarningAction SilentlyContinue
                }

                # Set parameters for Invoke-STIGScan
                $ScanArgs = @{
                    StigXmlPath    = $StigXmlPath
                    VulnTimeout    = $($VulnTimeout)
                    SelectVuln     = $SelectVuln
                    ExcludeVuln    = $ExcludeVuln
                    Deprecated     = $Item.Deprecated
                    Forced         = $Item.Forced
                    ModulesPath    = $(Join-Path -Path $PsScriptRoot -ChildPath "Modules")
                    PsModule       = $Item.PsModule
                    LogPath        = $STIGLog
                    OSPlatform     = $OSPlatform
                    ProgressId     = $ProgressId
                    ModuleArgs     = @{} # Initialze ModuleArgs object
                }

                # Set common arguments for scan module.  Additional variables and parameters may be added.
                $ScanArgs.ModuleArgs.Add("ScanType",$ScanType)
                if ($Item.AnswerFile.FullName){
                    $ScanArgs.ModuleArgs.Add("AnswerFile", "'$($Item.AnswerFile.FullName)'")
                }
                else{
                    $ScanArgs.ModuleArgs.Add("AnswerFile", "")
                }
                $ScanArgs.ModuleArgs.Add("AnswerKey", $AnswerKey)
                $ScanArgs.ModuleArgs.Add("Username", $UserToProcess.Username)
                $ScanArgs.ModuleArgs.Add("UserSID", $UserToProcess.SID)
                $ScanArgs.ModuleArgs.Add("ESVersion", $ESVersion)
                $ScanArgs.ModuleArgs.Add("LogPath", $STIGLog)
                $ScanArgs.ModuleArgs.Add("OSPlatform", $OSPlatform)
                $ScanArgs.ModuleArgs.Add("LogComponent", $LogComponent)

                # Determine additional arguments execute scan
                Switch ($Item.ShortName) {
                    {$_ -in @("Apache24SiteUnix", "Apache24SiteWin")} {
                        # Get all the instances of apache running and their relevant information.
                        $ApacheInstances = @(Get-ApacheInstances)

                        # Add additional module arguments
                        $ScanArgs.ModuleArgs.Add("ApacheInstance", $null)
                        $ScanArgs.ModuleArgs.Add("VirtualHost", $null)
                        $ScanArgs.ModuleArgs.Add("SiteName", "")

                        ForEach ($instance in $ApacheInstances) {
                            $ScanArgs.ModuleArgs.ApacheInstance = $instance
                            ForEach ($vhost in $instance.VirtualHosts) {
                                $ScanArgs.ModuleArgs.VirtualHost = $vhost
                                If ($vhost.Index -eq -1) {
                                    $ScanArgs.ModuleArgs.SiteName = ("BaseConfig-" + $instance.Index)
                                }
                                Else {
                                    $ScanArgs.ModuleArgs.SiteName = ($vhost.SiteName + "-" + $vhost.SitePort)
                                }

                                # Set output filename
                                $BaseFileName = "$($TargetData.HostName)_$($STIGData.ShortName)_$($ScanArgs.ModuleArgs.SiteName)_$($STIGData.StigVersion)" -replace "\s+", "_"

                                # Update TargetData
                                $TargetData.WebOrDatabase = $true
                                $TargetData.Site = $ScanArgs.ModuleArgs.SiteName
                                $TargetData.Instance = ""

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                        }
                    }
                    {$_ -in @("Apache24SvrUnix", "Apache24SvrWin")} {
                        # Get all the instances of apache running and their relevant information.
                        $ApacheInstances = @(Get-ApacheInstances)

                        # Add additional module arguments
                        $ScanArgs.ModuleArgs.Add("ApacheInstance", $null)
                        $ScanArgs.ModuleArgs.Add("VirtualHost", $null)
                        $ScanArgs.ModuleArgs.Add("SiteName", "")

                        ForEach ($instance in $ApacheInstances) {
                            $ScanArgs.ModuleArgs.ApacheInstance = $instance
                            $ScanArgs.ModuleArgs.SiteName = ("Server-" + $instance.Index)

                            # Set output filename
                            $BaseFileName = "$($TargetData.HostName)_$($STIGData.ShortName)_$($ScanArgs.ModuleArgs.SiteName)_$($STIGData.StigVersion)" -replace "\s+", "_"

                            # Update TargetData
                            $TargetData.WebOrDatabase = $true
                            $TargetData.Site = $ScanArgs.ModuleArgs.SiteName
                            $TargetData.Instance = ""

                            # Build and add sub job
                            $NewObj = [PSCustomObject]@{
                                BaseFileName = $BaseFileName
                                STIGInfo     = $STIGInfo
                                TargetData   = (Get-DeepCopy $TargetData)
                                ScanArgs     = (Get-DeepCopy $ScanArgs)
                            }
                            $SubJobs.Add($NewObj)
                        }
                    }
					"ArcGIS" {
                        [System.Collections.ArrayList]$ArcGISInstances = @(Get-ArcGISInstances)

                        # Add additional module arguments
                        $ScanArgs.ModuleArgs.Add("ArcGISInstance", $null)
                        $ScanArgs.ModuleArgs.Add("Instance", "")

                        ForEach ($instance in $ArcGISInstances) {
                            $XmlObject = Get-XMLObject -Path $instance.ApplicationHost
                            if ($null -ne $XmlObject) {
                                $SiteNames = Get-ArcGISSites -XmlObject $XmlObject
                                if (($SiteNames | Measure-Object).Count -eq 1) {
                                    $SiteName = $SiteNames.name
                                }
                                else {
                                    $SiteName = ($SiteNames[0]).name
                                }

                                $FileSiteName = $SiteName -replace " ","_"
                            }
                            else {
                                $SiteName = $("Server-" + $instance.Index)
                            }
                            $ScanArgs.ModuleArgs.ArcGISInstance = $instance
                            $ScanArgs.ModuleArgs.Instance = ($SiteName)

                            # Set output filename
                            $BaseFileName = "$($TargetData.HostName)_$($STIGData.ShortName)_$($FileSiteName)_$($STIGData.StigVersion)" -replace "\s+", "_"

                            $TargetData.WebOrDatabase = $true
                            $TargetData.Site = $($ScanArgs.ModuleArgs.Instance)
                            $TargetData.Instance = ""

                            # Build and add sub job
                            $NewObj = [PSCustomObject]@{
                                BaseFileName = $BaseFileName
                                STIGInfo     = $STIGInfo
								TargetData   = (Get-DeepCopy $TargetData)
								ScanArgs     = (Get-DeepCopy $ScanArgs)
                            }
                            $SubJobs.Add($NewObj)
                        }
                    }
                    "MSOffice365" {
                        # Set output filename
                        $BaseFileName = "$($TargetData.HostName)_$($STIGData.ShortName)_$($STIGData.StigVersion)" -replace "\s+", "_"

                        # Add additional module arguments
                        $ScanArgs.ModuleArgs.Add("InstalledO365Apps", $(Get-InstalledO365Apps))

                        # Build and add sub job
                        $NewObj = [PSCustomObject]@{
                            BaseFileName = $BaseFileName
                            STIGInfo     = $STIGInfo
                            TargetData   = (Get-DeepCopy $TargetData)
                            ScanArgs     = (Get-DeepCopy $ScanArgs)
                        }
                        $SubJobs.Add($NewObj)
                    }
                    {$_ -in @("IIS10Site","IIS85Site")} {
                        If (($PsVersionTable.PSVersion -join ".") -lt [Version]"6.0") {
                            Import-Module WebAdministration
                            $AllSites = Get-WebSite
                        }
                        Else {
                            $PSCommand = "PowerShell.exe -Command {Import-Module WebAdministration; Get-WebSite}"
                            $AllSites = Invoke-Expression $PSCommand
                        }

                        # Add additional module arguments
                        $ScanArgs.ModuleArgs.Add("SiteName", "")

                        ForEach ($Site in $Allsites) {
                            # Set output filename
                            $BaseFileName = "$($TargetData.HostName)_$($STIGData.ShortName)_$($Site.Name)_$($STIGData.StigVersion)" -replace "\s+", "_"

                            # Update TargetData
                            $TargetData.WebOrDatabase = $true
                            $TargetData.Site = $Site.Name
                            $TargetData.Instance = ""

                            # Set SiteName in module arguments
                            $ScanArgs.ModuleArgs.SiteName = "'$($Site.Name)'"

                            # Build and add sub job
                            $NewObj = [PSCustomObject]@{
                                BaseFileName = $BaseFileName
                                STIGInfo     = $STIGInfo
                                TargetData   = (Get-DeepCopy $TargetData)
                                ScanArgs     = (Get-DeepCopy $ScanArgs)
                            }
                            $SubJobs.Add($NewObj)
                        }
                    }
                    "JBoss" {
                        [System.Collections.ArrayList]$JBossInstances = @(Get-JBossInstances)

                        # Add additional module arguments
                        $ScanArgs.ModuleArgs.Add("JBossInstance", $null)
                        $ScanArgs.ModuleArgs.Add("Instance", "")

                        ForEach ($instance in $JBossInstances) {
                            $ScanArgs.ModuleArgs.JBossInstance = $instance
                            $ScanArgs.ModuleArgs.Instance = $instance.Server

                            # Set output filename
                            $BaseFileName = "$($TargetData.HostName)_$($STIGData.ShortName)_$($ScanArgs.ModuleArgs.Instance)_$($STIGData.StigVersion)" -replace "\s+", "_"

                            $TargetData.WebOrDatabase = $true
                                $TargetData.Site = ""
                                $TargetData.Instance = $($Instance.Name)

                            # Build and add sub job
                            $NewObj = [PSCustomObject]@{
                                BaseFileName = $BaseFileName
                                STIGInfo     = $STIGInfo
                                TargetData   = (Get-DeepCopy $TargetData)
                                ScanArgs     = (Get-DeepCopy $ScanArgs)
                            }
                            $SubJobs.Add($NewObj)
                        }
                    }
                    "TrellixENS10xLocal" {
                        # Set output filename
                        $BaseFileName = "$($TargetData.HostName)_$($STIGData.ShortName)_$($STIGData.StigVersion)" -replace "\s+", "_"

                        # Add additional module arguments
                        $ScanArgs.ModuleArgs.Add("EnsConfig", $(Get-EnsConfig))

                        # Build and add sub job
                        $NewObj = [PSCustomObject]@{
                            BaseFileName = $BaseFileName
                            STIGInfo     = $STIGInfo
                            TargetData   = (Get-DeepCopy $TargetData)
                            ScanArgs     = (Get-DeepCopy $ScanArgs)
                        }
                        $SubJobs.Add($NewObj)
                    }
                    "ApacheTomcatAS" {
                        [System.Collections.ArrayList]$TomcatInstances = @(Get-TomcatInstances)

                        # Add additional module arguments
                        $ScanArgs.ModuleArgs.Add("TomcatInstance", $null)
                        $ScanArgs.ModuleArgs.Add("Instance", "")

                        ForEach ($instance in $TomcatInstances) {
                            $ScanArgs.ModuleArgs.TomcatInstance = $instance
                            $ScanArgs.ModuleArgs.Instance = "$($instance.Bindings)"

                            if (($instance.Bindings | Measure-Object).Count -eq 1) {
                                $InstanceFileName = $instance.Bindings
                            }
                            else {
                                $InstanceFileName = $instance.Bindings[0]
                            }
                            $InstanceFileName = $InstanceFileName -replace ':', '-'

                            # Set output filename
                            $BaseFileName = "$($TargetData.HostName)_$($STIGData.ShortName)_$($InstanceFileName)_$($STIGData.StigVersion)" -replace "\s+", "_"

                            # Update TargetData
                            $TargetData.WebOrDatabase = $true
                            $TargetData.Site = $($ScanArgs.ModuleArgs.Instance)
                            $TargetData.Instance = ""

                            # Build and add sub job
                            $NewObj = [PSCustomObject]@{
                                BaseFileName = $BaseFileName
                                STIGInfo     = $STIGInfo
                                TargetData   = (Get-DeepCopy $TargetData)
                                ScanArgs     = (Get-DeepCopy $ScanArgs)
                            }
                            $SubJobs.Add($NewObj)
                        }
                    }
                    {$_ -in @("SQL2014Instance","SQL2016Instance")} {
                        Switch ($_) {
                            "SQL2014Instance" {
                                $allInstances = Get-AllInstances | Where-Object {[Version]$_.Version -like "12.*"}
                            }
                            "SQL2016Instance" {
                                $allInstances = Get-AllInstances | Where-Object {[Version]$_.Version -ge "13.0"}
                            }
                        }

                        # Add additional module arguments
                        $ScanArgs.ModuleArgs.Add("Instance", "")
                        $ScanArgs.ModuleArgs.Add("Database", "")

                        ForEach ($Instance in $allInstances) {
                            If ($Instance.Status -eq "Running") {
                                # Set output filename
                                $BaseFileName = "$($TargetData.HostName)_$($STIGData.ShortName)_$($Instance.Name.replace("\","-"))_$($STIGData.StigVersion)" -replace "\s+", "_"

                                # Update TargetData
                                $TargetData.WebOrDatabase = $true
                                $TargetData.Site = ""
                                $TargetData.Instance = $($Instance.Name)

                                # Set Instance and Database in module arguments
                                $ScanArgs.ModuleArgs.Instance = "'$($Instance.Name)'"
                                $ScanArgs.ModuleArgs.Database = "master"

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                        }
                    }
                    {$_ -in @("SQL2014DB", "SQL2016DB")} {
                        Switch ($_) {
                            "SQL2014DB" {
                                $allInstances = Get-AllInstances | Where-Object {[Version]$_.Version -like "12.*"}
                            }
                            "SQL2016DB" {
                                $allInstances = Get-AllInstances | Where-Object {[Version]$_.Version -ge "13.0"}
                            }
                        }

                        # Add additional module arguments
                        $ScanArgs.ModuleArgs.Add("Instance", "")
                        $ScanArgs.ModuleArgs.Add("Database", "")
                        ForEach ($Instance in $allInstances) {
                            If ($Instance.Status -eq "Running") {
                                $allDatabases = (Get-ISQL -ServerInstance $Instance.Name -qry "select name from sys.databases where state = 0").Name
                                ForEach ($Database in $allDatabases) {
                                    # Set output filename
                                    $BaseFileName = "$($TargetData.HostName)_$($STIGData.ShortName)_$($Instance.Name.replace("\","-"))_$($Database)_$($STIGData.StigVersion)" -replace "\s+", "_"

                                    # Update TargetData
                                    $TargetData.WebOrDatabase = $true
                                    $TargetData.Site = $Database
                                    $TargetData.Instance = $($Instance.Name)

                                    # Set Instance and Database in module arguments
                                    $ScanArgs.ModuleArgs.Instance = "'$($Instance.Name)'"
                                    $ScanArgs.ModuleArgs.Database = "'$($Database)'"

                                    # Build and add sub job
                                    $NewObj = [PSCustomObject]@{
                                        BaseFileName = $BaseFileName
                                        STIGInfo     = $STIGInfo
                                        TargetData   = (Get-DeepCopy $TargetData)
                                        ScanArgs     = (Get-DeepCopy $ScanArgs)
                                    }
                                    $SubJobs.Add($NewObj)
                                }
                            }
                        }
                    }
                    "PgSQL9x" {
                        [System.Collections.ArrayList]$PgInstances = @(Get-PostgreSQLInstances)

                        # Add additional module arguments
                        $ScanArgs.ModuleArgs.Add("PGInstance", $null)
                        $ScanArgs.ModuleArgs.Add("Instance", "")
                        $ScanArgs.ModuleArgs.Add("Database", "")

                        ForEach ($instance in $PgInstances) {
                            If ($instance.PSQLAccess) {
                                $ScanArgs.ModuleArgs.PGInstance = $instance
                                $ScanArgs.ModuleArgs.Instance = ($instance.Server + "-" + $instance.Port)
                                $ScanArgs.ModuleArgs.Database = $instance.Database

                                # Set output filename
                                $BaseFileName = "$($TargetData.HostName)_$($STIGData.ShortName)_$($ScanArgs.ModuleArgs.Instance)_$($ScanArgs.ModuleArgs.Database)_$($STIGData.StigVersion)" -replace "\s+", "_"

                                # Update TargetData
                                $TargetData.WebOrDatabase = $true
                                $TargetData.Site = $($instance.Server)
                                $TargetData.Instance = $($instance.Database)

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                            Else {
                                Write-Log -Path $STIGLog -Message "----------------Skipping CKL------------------" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                Write-Log -Path $STIGLog -Message "ERROR: STIG: $($STIG.Name) PSQL access requirement not met." -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                $HbaFile = Join-Path -Path "$($instance.PG_DATA)" -ChildPath "pg_hba.conf"
                                Write-Log -Path $STIGLog -Message "ERROR: Local trust authentication method must be set in $($HbaFile)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                Write-Log -Path $STIGLog -Message "ERROR: Skipping Server: $($instance.Server), Port: $($instance.Port), Database: $($instance.Database) " -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            }
                        }
                    }
                    Default {
                        # Set output filename
                        $BaseFileName = "$($TargetData.HostName)_$($STIGData.ShortName)_$($STIGData.StigVersion)" -replace "\s+","_"

                        # Build and add sub job
                        $NewObj = [PSCustomObject]@{
                            BaseFileName = $BaseFileName
                            STIGInfo     = $STIGInfo
                            TargetData   = (Get-DeepCopy $TargetData)
                            ScanArgs     = (Get-DeepCopy $ScanArgs)
                        }
                        $SubJobs.Add($NewObj)
                    }
                }

                # Add scan job
                $NewObj = [PSCustomObject]@{
                    STIGData = $STIGData
                    SubJobs  = $SubJobs
                }
                $ScanJobs.Add($NewObj)

                # Remove module after adding job to queue.  Will be imported for scan when needed.
                Remove-Module $Item.PsModule -Force
            }

            # Execute the scans
            $FailedCheck = $false
            ForEach ($Job in $ScanJobs) {
                Try {
                    Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Evaluating STIG: $($Job.STIGData.Name)" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                    Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    $CurrentMainStep++

                    Write-Log -Path $STIGLog -Message "Invoking scan" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    $ModError = ""
                    Try {

                        Write-Log -Path $STIGLog -Message "Importing scan module: $($Job.STIGData.PsModule)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        If ($PowerShellVersion -lt [Version]"7.0") {
                            Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Job.STIGData.PsModule)) -ErrorAction Stop
                        }
                        Else {
                            Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Job.STIGData.PsModule)) -SkipEditionCheck -ErrorAction Stop
                        }
                        $PsModule = (Get-Module $Job.STIGData.PsModule)
                        Write-Log -Path $STIGLog -Message "Module Version: $($PsModule.Version)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    }
                    Catch {
                        $ModError = $_.Exception.Message
                    }

                    If ($ModError) {
                        # If module failed to import, display reason and continue to next STIG.
                        Write-Log -Path $STIGLog -Message "ERROR: $($ModError)" -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    }
                    Else {
                        # Build ESData Object
                        $ESData = [Ordered]@{
                            ESVersion     = $ESVersion
                            StartTime     = (Get-Date -Format 'o')
                            ModuleName    = $PsModule.Name
                            ModuleVersion = $PsModule.Version
                            STIGName      = $Job.STIGData.Name
                            STIGShortName = $Job.STIGData.ShortName
                            CanCombine    = $Job.STIGData.CanCombine
                            STIGXMLName   = $($Job.STIGData.StigXmlPath | Split-Path -Leaf)
                            BaseFileName  = ""
                            FileName      = ""
                        }

                        # Set filename and additional requirements
                        ForEach ($SubJob in $Job.SubJobs) {
                            # Update BaseFileName if -SelectVuln is used
                            If ($SelectVuln) {
                                $SubJob.BaseFileName = "Partial_$($SubJob.BaseFileName)"
                            }

                            $ESData.BaseFileName = $($SubJob.BaseFileName)

                            # Write Site/Intance info to log
                            If ($SubJob.TargetData.Site) {
                                Write-Log -Path $STIGLog -Message "Site: $($SubJob.TargetData.Site)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            }
                            If ($SubJob.TargetData.Instance) {
                                Write-Log -Path $STIGLog -Message "Instance: $($SubJob.TargetData.Instance)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            }

                            # Execute scan
                            $ScanArgs = $SubJob.ScanArgs
                            $VulnResults = Invoke-STIGScan @ScanArgs

                            # Look for any failed checks
                            If ($VulnResults | Where-Object CheckError -eq $true) {
                                $FailedCheck = $true
                            }

                            # Build ScanObject
                            $ScanObject = [System.Collections.Generic.List[System.Object]]::new()
                            $NewObj = [PSCustomObject]@{
                                ESData      = $ESData
                                STIGInfo    = $SubJob.STIGInfo
                                TargetData  = $SubJob.TargetData
                                VulnResults = $VulnResults
                            }
                            $ScanObject.Add($NewObj)

                            # Send ScanObject to outputs (CKL, CKLB)
                            If ($Output -match @("(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$)")) {
                                Write-Progress -Id ($ProgressId + 1) -ParentId $ProgressId -Activity "Generating checklists..."
                                $tmpChecklistPath = Join-Path -Path $tmpResultsPath -ChildPath "Checklist"
                                If (-Not(Test-Path $tmpChecklistPath)) {
                                    $null = New-Item -Path $tmpChecklistPath -ItemType Directory
                                }
                                $GenerateSingleCKL = $false
                                $GenerateSingleCKLB = $false
                                If ("CKL" -in $Output) {
                                    $GenerateSingleCKL = $true
                                }
                                If ("CombinedCKL" -in $Output) {
                                    If ($ScanObject.ESData.CanCombine -ne $true) {
                                        $GenerateSingleCKL = $true
                                    }
                                }
                                If ("CKLB" -in $Output) {
                                    $GenerateSingleCKLB = $true
                                }
                                If ("CombinedCKLB" -in $Output) {
                                    If ($ScanObject.ESData.CanCombine -ne $true) {
                                        $GenerateSingleCKLB = $true
                                    }
                                }

                                If ($GenerateSingleCKL) {
                                    Write-Log -Path $STIGLog -Message "Creating CKL file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                    $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($ESData.BaseFileName)_$(Get-Date -Format yyyyMMdd-HHmmss).ckl")
                                    $ChecklistValid = Format-CKL -SchemaPath $Checklist_xsd -ScanObject $ScanObject -OutputPath $SaveFile -Marking $Marking -WorkingDir $WorkingDir -ESPath $PSScriptRoot -OSPlatform $OSPlatform -LogComponent $LogComponent

                                    # Action for validation result
                                    If ($ChecklistValid) {
                                        $ScanObject.ESData.FileName = $(Split-Path $SaveFile -Leaf)
                                    }
                                }

                                If ($GenerateSingleCKLB) {
                                    Write-Log -Path $STIGLog -Message "Creating CKLB file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                    $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($ESData.BaseFileName)_$(Get-Date -Format yyyyMMdd-HHmmss).cklb")
                                    $ChecklistValid = Format-CKLB -SchemaPath $Checklist_json -ScanObject $ScanObject -OutputPath $SaveFile -WorkingDir $WorkingDir -ESPath $PSScriptRoot -OSPlatform $OSPlatform -LogComponent $LogComponent

                                    # Action for validation result
                                    If ($ChecklistValid) {
                                        $ScanObject.ESData.FileName = $(Split-Path $SaveFile -Leaf)
                                    }
                                }
                                Write-Progress -Id ($ProgressId + 1) -ParentId $ProgressId -Activity "Generating checklists..." -Completed
                            }
                            # Add to ScanObjects object console or combined checklist output
                            $ScanObjects.Add($ScanObject)
                        }

                        Write-Log -Path $STIGLog -Message "Removing scan module from memory" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Remove-Module $Job.STIGData.PsModule -Force

                        [System.GC]::Collect()
                    }
                }
                Catch {
                    Write-Log -Path $STIGLog -Message "    $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    Write-Log -Path $STIGLog -Message "    $($_.InvocationInfo.ScriptName)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    Write-Log -Path $STIGLog -Message "    Line: $($_.InvocationInfo.ScriptLineNumber)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    Write-Log -Path $STIGLog -Message "    $(($_.InvocationInfo.Line).Trim())" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    Write-Log -Path $STIGLog -Message "Continuing Processing" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    [System.GC]::Collect()
                }
            }

            # Create combined checklists
            If ($Output -match @("(^CombinedCKL$|^CombinedCKLB$)")) {
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Generating combined checklists" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                $CurrentMainStep++
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                If ("CombinedCKL" -in $Output) {
                    Write-Log -Path $STIGLog -Message "Creating combined CKL file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    # Set combined checklist filename
                    If ($SelectVuln) {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "Partial_$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).ckl")
                    }
                    Else {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).ckl")
                    }
                    $null = Format-CKL -SchemaPath $Checklist_xsd -ScanObject $ScanObjects -OutputPath $SaveFile -Marking $Marking -WorkingDir $WorkingDir -ESPath $PSScriptRoot -OSPlatform $OSPlatform -LogComponent $LogComponent
                }
                If ("CombinedCKLB" -in $Output) {
                    Write-Log -Path $STIGLog -Message "Creating combined CKLB file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    # Set combined checklist filename
                    If ($SelectVuln) {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "Partial_$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).cklb")
                    }
                    Else {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).cklb")
                    }
                    $null = Format-CKLB -SchemaPath $Checklist_json -ScanObject $ScanObjects -OutputPath $SaveFile -WorkingDir $WorkingDir -ESPath $PSScriptRoot -OSPlatform $OSPlatform -LogComponent $LogComponent
                }
            }

            If ($FailedCheck -eq $true) {
                Write-Log -Path $STIGLog -Message "Please report issues to https://spork.navsea.navy.mil/nswc-crane-division/evaluate-stig/-/issues" -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
            }

            # Send results to STIG Manager
            If ("STIGManager" -in $Output) {
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Importing to STIG Manager" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                $CurrentMainStep++

                Try {
                    Import-Module (Join-Path -Path $PSScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "STIGManager_Functions") -SkipEditionCheck -ErrorAction Stop

                    if ($SMPassphrase) {
                        $SMImport_Params = Get-SMParameters -SMCollection $SMCollection -SMPassphrase $SMPassphrase -ScanObject $ScanObjects -ScriptRoot $PsScriptRoot -WorkingDir $WorkingDir -OSPlatform $OSPlatform -LogComponent $LogComponent -Logpath $STIGLog
                    }
                    else{
                        $SMImport_Params = Get-SMParameters -SMCollection $SMCollection -ScanObject $ScanObjects -ScriptRoot $PsScriptRoot -WorkingDir $WorkingDir -OSPlatform $OSPlatform -LogComponent $LogComponent -Logpath $STIGLog
                    }

                    Import-Asset @SMImport_Params
                }
                Catch {
                    Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                }
            }

            # Create OQE
            If ($Output -contains "OQE") {
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Switch ($OSPlatform) {
                    "Windows" {
                        Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Generating Objective Quality Evidence (OQE) output" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                        $CurrentMainStep++
                        Write-Log -Path $STIGLog -Message "Generating Objective Quality Evidence (OQE) output" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Try {
                            $tmpOQEPath = $(Join-Path -Path $tmpResultsPath -ChildPath "OQE")
                            If (-Not(Test-Path $tmpOQEPath)) {
                                $null = New-Item -Path $tmpOQEPath -ItemType Directory
                            }

                            # Group Policy Report
                            Try {
                                Write-Log -Path $STIGLog -Message "Pulling Group Policy Report" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                $GPResultFile = "GPResult_$(${env:computername})_$($Date).html"
                                If ($UserToProcess -and $UserToProcess.SID -notin @("NA", ".DEFAULT")) {
                                    Start-Process -FilePath GPResult.exe -ArgumentList "/USER $($UserToProcess.Username) /H $tmpOQEPath\$($GPResultFile)" -Wait -WindowStyle Hidden
                                }
                                Else {
                                    Write-Log -Path $STIGLog -Message "    No profile selected as user to evaluate.  Group Policy results will not include user policies." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                                    Start-Process -FilePath GPResult.exe -ArgumentList "/SCOPE COMPUTER /H $tmpOQEPath\$($GPResultFile)" -Wait -WindowStyle Hidden
                                }
                            }
                            Catch {
                                Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            }

                            # AppLocker Report
                            Try {
                                Write-Log -Path $STIGLog -Message "Collecting AppLocker effective policy" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                $AppLockerPolFile = "AppLockerPol_$(${env:computername})_$($Date).xml"
                                If (($PsVersionTable.PSVersion -join ".") -lt [Version]"7.0") {
                                    Import-Module AppLocker
                                }
                                Else {
                                    Import-Module AppLocker -SkipEditionCheck
                                }
                                Get-AppLockerPolicy -Effective -Xml -ErrorAction Stop | Out-File $tmpOQEPath\$($AppLockerPolFile) -Force -Encoding UTF8
                            }
                            Catch {
                                Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            }

                            # Security Policy
                            Try {
                                $SecPolFile = "SecPol_$(${env:computername})_$($Date).ini"
                                Write-Log -Path $STIGLog -Message "Exporting security policy" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                Start-Process -FilePath secedit.exe -ArgumentList "/export /cfg $($tmpOQEPath)\$($SecPolFile)" -Wait -WindowStyle Hidden
                            }
                            Catch {
                                Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            }
                        }
                        Catch {
                            Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                    }
                    "Linux" {
                        $CurrentMainStep++
                        # Placeholder in the event there is something we want to provide as OQE for Linux systems.
                    }
                }
            }

            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            If ($Output -contains "Summary") {
                # Create summary report
                Write-Log -Path $STIGLog -Message "Generating summary report" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Generating summary report" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                $CurrentMainStep++
                if ($Marking) {
                    Write-SummaryReport -ScanResult $ScanObjects -OutputPath $tmpResultsPath -ProcessedUser $UserToProcess.Username -Detail -OSPlatform $OSPlatform -ScanStartDate $ScanStartDate -ScanType $ScanType -Marking $Marking
                }
                else {
                    Write-SummaryReport -ScanResult $ScanObjects -OutputPath $tmpResultsPath -ProcessedUser $UserToProcess.Username -Detail -OSPlatform $OSPlatform -ScanStartDate $ScanStartDate -ScanType $ScanType
                }

                # Create Summary HTML
                $SummaryFile = Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.xml
                [xml]$TempSR = New-Object xml

                $null = $TempSR.AppendChild($TempSR.CreateElement('Summaries'))
                $summary = New-Object xml
                $Summary.Load($SummaryFile)
                $ImportedSummary = $TempSR.ImportNode($Summary.DocumentElement, $true)
                $null = $TempSR.DocumentElement.AppendChild($ImportedSummary)

                $TempSR.Summaries.Summary.Results.Result | ForEach-Object {
                    #Build STIG name
                    $STIGName = [String]"$($_.STIG -replace '_', ' ') V$($_.Version)R$($_.Release)"
                    If ($_.Site) {
                        $STIGName = $STIGName + " ($($_.Site))"
                    }
                    If ($_.Instance) {
                        $STIGName = $STIGName + " ($($_.Instance))"
                    }
                    $_.SetAttribute("STIG", $STIGName)
                    $_.SetAttribute("StartTime", [String]($_.StartTime -replace "\.\d+", ""))
                    $CurrentScoreNode = $_.AppendChild($TempSR.CreateElement('CurrentScore'))
                    $CurrentScore = ([int]$_.CAT_I.NotAFinding + [int]$_.CAT_II.NotAFinding + [int]$_.CAT_III.NotAFinding + [int]$_.CAT_I.Not_Applicable + [int]$_.CAT_II.Not_Applicable + [int]$_.CAT_III.Not_Applicable) / ([int]$_.CAT_I.Total + [int]$_.CAT_II.Total + [int]$_.CAT_III.Total)
                    $CurrentScoreNode.SetAttribute("Score", $CurrentScore)
                }
                $TempSR.Save($(Join-Path -Path $WorkingDir -ChildPath TempSR.xml))

                $SummaryReportXLST = New-Object System.XML.Xsl.XslCompiledTransform
                $SummaryReportXLST.Load($(Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath SummaryReport.xslt))
                $SummaryReportXLST.Transform($(Join-Path -Path $WorkingDir -ChildPath TempSR.xml), $(Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.html))

                if ($Marking) {
                    #Add Marking Header and Footer
                    $SRHTML = $(Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.html)
                    (Get-Content $SRHTML) -replace "<body>", "<body>`n    <header align=`"center`">$Marking</header>" | Set-Content $SRHTML

                    Add-Content $(Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.html) "<footer align=`"center`">$Marking</footer>"
                }
            }

            # Manage previous results and move results to ResultsPath
            If ($Output -match @("(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$|^Summary$|^OQE$)")) {
                If ($SelectSTIG) {
                    $PreviousArgs = @{SelectedShortName = $STIGsToProcess.ShortName}
                    If ($Output -match @("(^CombinedCKL$)")) {
                        $PreviousArgs.Add("SelectedCombinedCKL",$true)
                    }
                    If ($Output -match @("(^CombinedCKLB$)")) {
                        $PreviousArgs.Add("SelectedCombinedCKLB", $true)
                    }
                    If ($Output -match @("(^Summary$)")) {
                        $PreviousArgs.Add("SelectedSummary", $true)
                    }
                    If ($Output -match @("(^OQE$)")) {
                        $PreviousArgs.Add("SelectedOQE", $true)
                    }
                    Initialize-PreviousProcessing -ResultsPath $ResultsPath -PreviousToKeep $PreviousToKeep @PreviousArgs -LogPath $STIGLog -LogComponent $LogComponent -OSPlatform $OSPlatform
                }
                Else {
                    Initialize-PreviousProcessing -ResultsPath $ResultsPath -PreviousToKeep $PreviousToKeep -LogPath $STIGLog -LogComponent $LogComponent -OSPlatform $OSPlatform
                }

                # Move results to ResultsPath
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Log -Path $STIGLog -Message "Copying output files to $ResultsPath" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Get-ChildItem $tmpResultsPath -Recurse | ForEach-Object {
                    If ($_.PSIsContainer) {
                        If (-Not(Test-Path $(Join-Path $ResultsPath -ChildPath $_.Name))) {
                            $null = New-Item -Path $(Join-Path $ResultsPath -ChildPath $_.Name) -ItemType Directory
                        }
                    }
                    Else {
                        Copy-Item -Path $_.FullName -Destination $(Join-Path -Path $ResultsPath -ChildPath $(($_.DirectoryName) -ireplace [regex]::Escape($tmpResultsPath),""))
                    }
                }
            }

            # Apply tattoo
            If ($ApplyTattoo) {
                Write-Log -Path $STIGLog -Message "Applying Evaluate-STIG tattoo" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Switch ($OSPlatform) {
                    "Windows" {
                        # Mark registry with EvaluateStigVersion.  This can be used for SCCM detection method.
                        $RegistryPath = "HKLM:\SOFTWARE\Evaluate-STIG"
                        If (-Not(Test-Path -Path $RegistryPath)) {
                            $null = New-Item -Path $RegistryPath -Force
                        }
                        Write-Log -Path $STIGLog -Message "Creating 'Version' value under HKLM:\SOFTWARE\Evaluate-STIG" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        $null = New-ItemProperty -Path $RegistryPath -Name Version -Value $ESVersion -PropertyType String -Force

                        Write-Log -Path $STIGLog -Message "Creating 'LastRun' value under HKLM:\SOFTWARE\Evaluate-STIG" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        $null = New-ItemProperty -Path $RegistryPath -Name LastRun -Value $(Get-Date -Format FileDateTime) -PropertyType String -Force
                    }
                    "Linux" {
                        Write-Log -Path $STIGLog -Message "Creating 'Version' value in /etc/Evaluate-STIG" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        "Version: $ESVersion" | Out-File /etc/Evaluate-STIG

                        Write-Log -Path $STIGLog -Message "Creating 'LastRun' value in /etc/Evaluate-STIG" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        "LastRun: $(Get-Date -Format FileDateTime)" | Out-File /etc/Evaluate-STIG -Append
                    }
                }
            }

            # Clean up
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
            Invoke-ScanCleanup -WorkingDir $WorkingDir -Logpath $STIGLog -OSPlatform $OSPlatform -LogComponent $LogComponent

            # Finalize log and get totals
            $TimeToComplete = New-TimeSpan -Start $StartTime -End (Get-Date)
            $FormatedTime = "{0:c}" -f $TimeToComplete
            Write-Log -Path $STIGLog -Message "Done!" -WriteOutToStream -FGColor Green -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Total Time : $($FormatedTime)" -WriteOutToStream -FGColor Green -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            If ($Output -match @("(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$)")) {
                $TotalChecklists = (Get-ChildItem -Path "$ResultsPath\Checklist" | Where-Object Extension -in @(".ckl", ".cklb") | Measure-Object).Count
                Write-Log -Path $STIGLog -Message "Total checklists in Results Directory : $($TotalChecklists)" -WriteOutToStream -FGColor Green -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Host ""
                Write-Host "Results saved to " -ForegroundColor Green -NoNewline; Write-Host "$($ResultsPath)" -ForegroundColor Cyan
            }
            Write-Log -Path $STIGLog -Message "End Local Logging" -TemplateMessage LineBreak-Text -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            If ($Marking) {
                Write-Log -Path $STIGLog -Message "                                                                                          $Marking                                                                                          " -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }
            Write-Host ""

            # Copy Evaluate-STIG.log to results path
            If ($Output -match @("(^CKL$|^CKLB$|^CombinedCKL$|^CombinedCKLB$|^Summary$|^OQE$)")) {
                Copy-Item $STIGLog -Destination $ResultsPath -Force -ErrorAction Stop
            }

            # Complete progress bar
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -Completed

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

            # Build ScanResult
            $ScanResult = @{}
            $ScanResult.Add($MachineName,$ScanObjects)
        }
        Catch {
            If ($_.TargetObject.ExitCode) {
                $ExitCode = $_.TargetObject.ExitCode
                $Message = $_.TargetObject.Message
            }
            Else {
                $ExitCode = 1
                $Message = $_.Exception.Message
            }

            # Clean up
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
            Invoke-ScanCleanup -WorkingDir $WorkingDir -Logpath $STIGLog -Message $Message -ExitCode $ExitCode -ErrorData $_ -OSPlatform $OSPlatform -LogComponent $LogComponent
            Write-Log -Path $STIGLog -Message "End Local Logging" -TemplateMessage LineBreak-Text -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Complete progress bar
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -Completed

            # Remove InstalledSoftware variable if it exists
            If ($null -ne $Global:InstalledSoftware) {
                Remove-Variable -Name InstalledSoftware -Scope Global
            }

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

            # Exit with code
            Exit $ExitCode
        }
    }

    # Remove InstalledSoftware variable if it exists
    If ($null -ne $Global:InstalledSoftware) {
        Remove-Variable -Name InstalledSoftware -Scope Global
    }

    # Remove Evaluate-STIG modules from memory
    Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force

    If ($Output -match "^Console$") {
        If (($ScanResult.Keys | Measure-Object).Count -ge 1) {
            # Configure a default display set
            $defaultDisplaySet = 'STIGInfo', 'TargetData', 'VulnResults'

            # Create the default property display set
            $defaultDisplayPropertySet = New-Object System.Management.Automation.PSPropertySet('DefaultDisplayPropertySet', [string[]]$defaultDisplaySet)
            $PSStandardMembers = [System.Management.Automation.PSMemberInfo[]]@($defaultDisplayPropertySet)

            # Format, sort, and return output
            $ScanOutput = [ordered]@{}
            If ($ComputerName) {
                ForEach ($HostName in ($ScanResult.Keys | Sort-Object)) {
                    $STIGOutput = [ordered]@{}
                    ForEach ($Target in ($ScanResult.$HostName.Keys | Sort-Object)) {
                        $OutObject = $ScanResult.$HostName.$Target | Select-Object STIGInfo, TargetData, VulnResults, ESdata
                        $OutObject.PSObject.TypeNames.Insert(0, 'ScanResult')
                        $OutObject | Add-Member MemberSet PSStandardMembers $PSStandardMembers
                        $STIGOutput.Add($($Target), $OutObject)
                    }
                    $ScanOutput.Add($HostName, $STIGOutput)
                }
            }
            Else {
                $tmpOutput = @{}
                ForEach ($Target in $ScanResult.Keys | Sort-Object) {
                    $STIGOutput = [ordered]@{}

                    $STIGCount = @{}
                    # Handle if STIG has more than a count of 1
                    $ScanResult[$Target].ESData.STIGShortName | Sort-Object -Unique | ForEach-Object {
                        $STIGCount | Add-Member -MemberType NoteProperty -Name $_ -Value 1
                    }
                    $GroupedObj = $ScanResult.$Target.ESData.STIGShortName.GetEnumerator() | Group-Object

                    Foreach ($Object in $ScanResult[$Target]) {
                        $OutObject = $Object | Select-Object STIGInfo, TargetData, VulnResults, ESdata
                        $OutObject.PSObject.TypeNames.Insert(0, 'ScanResult')
                        $OutObject | Add-Member MemberSet PSStandardMembers $PSStandardMembers

                        $STIGShortName = $Object.ESData.STIGShortName
                        if (($GroupedObj | Where-Object {$_.Name -like $STIGShortName}).Count -gt 1) {
                            $STIGCount[$STIGShortName]++
                            $STIGOutput.Add("$STIGShortName$($STIGCount[$STIGShortName])", $OutObject)
                        }
                        Else {
                            $STIGOutput.Add($($STIGShortName), $OutObject)
                        }
                    }
                    $tmpOutput.Add($Target, $STIGOutput)
                }

                # Put into new object to ensure sorting
                $HostName = $tmpOutput.GetEnumerator().Name
                $OrderedResults = [ordered]@{}
                ($tmpOutput.$($HostName).GetEnumerator() | Sort-Object Name) | ForEach-Object {
                    $OrderedResults.Add($($_.Name), $($tmpOutput.$($HostName).$($_.Name)))
                }
                $ScanOutput.Add($HostName, $OrderedResults)
            }
            Return $ScanOutput
        }
    }
}

# SIG # Begin signature block
# MIIL+QYJKoZIhvcNAQcCoIIL6jCCC+YCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCB3PsWOwxorOIjh
# +NVjDQybOVcfr/+jQeHIITmMU45U4qCCCTswggR6MIIDYqADAgECAgQDAgTXMA0G
# CSqGSIb3DQEBCwUAMFoxCzAJBgNVBAYTAlVTMRgwFgYDVQQKEw9VLlMuIEdvdmVy
# bm1lbnQxDDAKBgNVBAsTA0RvRDEMMAoGA1UECxMDUEtJMRUwEwYDVQQDEwxET0Qg
# SUQgQ0EtNTkwHhcNMjAwNzE1MDAwMDAwWhcNMjUwNDAyMTMzODMyWjBpMQswCQYD
# VQQGEwJVUzEYMBYGA1UEChMPVS5TLiBHb3Zlcm5tZW50MQwwCgYDVQQLEwNEb0Qx
# DDAKBgNVBAsTA1BLSTEMMAoGA1UECxMDVVNOMRYwFAYDVQQDEw1DUy5OU1dDQ0Qu
# MDAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2/Z91ObHZ009DjsX
# ySa9T6DbT+wWgX4NLeTYZwx264hfFgUnIww8C9Mm6ht4mVfo/qyvmMAqFdeyhXiV
# PZuhbDnzdKeXpy5J+oxtWjAgnWwJ983s3RVewtV063W7kYIqzj+Ncfsx4Q4TSgmy
# ASOMTUhlzm0SqP76zU3URRj6N//NzxAcOPLlfzxcFPMpWHC9zNlVtFqGtyZi/STj
# B7ed3BOXmddiLNLCL3oJm6rOsidZstKxEs3I1llWjsnltn7fR2/+Fm+roWrF8B4z
# ekQOu9t8WRZfNohKoXVtVuwyUAJQF/8kVtIa2YyxTUAF9co9qVNZgko/nx0gIdxS
# hxmEvQIDAQABo4IBNzCCATMwHwYDVR0jBBgwFoAUdQmmFROuhzz6c5QA8vD1ebmy
# chQwQQYDVR0fBDowODA2oDSgMoYwaHR0cDovL2NybC5kaXNhLm1pbC9jcmwvRE9E
# SURDQV81OV9OQ09ERVNJR04uY3JsMA4GA1UdDwEB/wQEAwIHgDAWBgNVHSAEDzAN
# MAsGCWCGSAFlAgELKjAdBgNVHQ4EFgQUVusXc6nN92xmQ3XNN+/76hosJFEwZQYI
# KwYBBQUHAQEEWTBXMDMGCCsGAQUFBzAChidodHRwOi8vY3JsLmRpc2EubWlsL3Np
# Z24vRE9ESURDQV81OS5jZXIwIAYIKwYBBQUHMAGGFGh0dHA6Ly9vY3NwLmRpc2Eu
# bWlsMB8GA1UdJQQYMBYGCisGAQQBgjcKAw0GCCsGAQUFBwMDMA0GCSqGSIb3DQEB
# CwUAA4IBAQBCSdogBcOfKqyGbKG45lLicG1LJ2dmt0Hwl7QkKrZNNEDh2Q2+uzB7
# SRmADtSOVjVf/0+1B4jBoyty90WL52rMPVttb8tfm0f/Wgw6niz5WQZ+XjFRTFQa
# M7pBNU54vI3bH4MFBTXUOEoSr0FELFQaByUWfWKrGLnEqYtpDde5FZEYKRv6td6N
# ZH7m5JOiCfEK6gun3luq7ckvx5zIXjr5VKhp+S0Aai3ZR/eqbBZ0wcUF3DOYlqVs
# LiPT0jWompwkfSnxa3fjNHD+FKvd/7EMQM/wY0vZyIObto3QYrLru6COAyY9cC/s
# Dj+R4K4392w1LWdo3KrNzkCFMAX6j/bWMIIEuTCCA6GgAwIBAgICAwUwDQYJKoZI
# hvcNAQELBQAwWzELMAkGA1UEBhMCVVMxGDAWBgNVBAoTD1UuUy4gR292ZXJubWVu
# dDEMMAoGA1UECxMDRG9EMQwwCgYDVQQLEwNQS0kxFjAUBgNVBAMTDURvRCBSb290
# IENBIDMwHhcNMTkwNDAyMTMzODMyWhcNMjUwNDAyMTMzODMyWjBaMQswCQYDVQQG
# EwJVUzEYMBYGA1UEChMPVS5TLiBHb3Zlcm5tZW50MQwwCgYDVQQLEwNEb0QxDDAK
# BgNVBAsTA1BLSTEVMBMGA1UEAxMMRE9EIElEIENBLTU5MIIBIjANBgkqhkiG9w0B
# AQEFAAOCAQ8AMIIBCgKCAQEAzBeEny3BCletEU01Vz8kRy8cD2OWvbtwMTyunFaS
# hu+kIk6g5VRsnvbhK3Ho61MBmlGJc1pLSONGBhpbpyr2l2eONAzmi8c8917V7Bpn
# JZvYj66qGRmY4FXX6UZQ6GdALKKedJKrMQfU8LmcBJ/LGcJ0F4635QocGs9UoFS5
# hLgVyflDTC/6x8EPbi/JXk6N6iod5JIAxNp6qW/5ZBvhiuMo19oYX5LuUy9B6W7c
# A0cRygvYcwKKYK+cIdBoxAj34yw2HJI8RQt490QPGClZhz0WYFuNSnUJgTHsdh2V
# NEn2AEe2zYhPFNlCu3gSmOSp5vxpZWbMIQ8cTv4pRWG47wIDAQABo4IBhjCCAYIw
# HwYDVR0jBBgwFoAUbIqUonexgHIdgXoWqvLczmbuRcAwHQYDVR0OBBYEFHUJphUT
# roc8+nOUAPLw9Xm5snIUMA4GA1UdDwEB/wQEAwIBhjBnBgNVHSAEYDBeMAsGCWCG
# SAFlAgELJDALBglghkgBZQIBCycwCwYJYIZIAWUCAQsqMAsGCWCGSAFlAgELOzAM
# BgpghkgBZQMCAQMNMAwGCmCGSAFlAwIBAxEwDAYKYIZIAWUDAgEDJzASBgNVHRMB
# Af8ECDAGAQH/AgEAMAwGA1UdJAQFMAOAAQAwNwYDVR0fBDAwLjAsoCqgKIYmaHR0
# cDovL2NybC5kaXNhLm1pbC9jcmwvRE9EUk9PVENBMy5jcmwwbAYIKwYBBQUHAQEE
# YDBeMDoGCCsGAQUFBzAChi5odHRwOi8vY3JsLmRpc2EubWlsL2lzc3VlZHRvL0RP
# RFJPT1RDQTNfSVQucDdjMCAGCCsGAQUFBzABhhRodHRwOi8vb2NzcC5kaXNhLm1p
# bDANBgkqhkiG9w0BAQsFAAOCAQEAOQUb0g6nPvWoc1cJ5gkhxSyGA3bQKu8HnKbg
# +vvMpMFEwo2p30RdYHGvA/3GGtrlhxBqAcOqeYF5TcXZ4+Fa9CbKE/AgloCuTjEY
# t2/0iaSvdw7y9Vqk7jyT9H1lFIAQHHN3TEwN1nr7HEWVkkg41GXFxU01UHfR7vgq
# TTz+3zZL2iCqADVDspna0W5pF6yMla6gn4u0TmWu2SeqBpctvdcfSFXkzQBZGT1a
# D/W2Fv00KwoQgB2l2eiVk56mEjN/MeI5Kp4n57mpREsHutP4XnLQ01ZN2qgn+844
# JRrzPQ0pazPYiSl4PeI2FUItErA6Ob/DPF0ba2y3k4dFkUTApzGCAhQwggIQAgEB
# MGIwWjELMAkGA1UEBhMCVVMxGDAWBgNVBAoTD1UuUy4gR292ZXJubWVudDEMMAoG
# A1UECxMDRG9EMQwwCgYDVQQLEwNQS0kxFTATBgNVBAMTDERPRCBJRCBDQS01OQIE
# AwIE1zANBglghkgBZQMEAgEFAKCBhDAYBgorBgEEAYI3AgEMMQowCKACgAChAoAA
# MBkGCSqGSIb3DQEJAzEMBgorBgEEAYI3AgEEMBwGCisGAQQBgjcCAQsxDjAMBgor
# BgEEAYI3AgEVMC8GCSqGSIb3DQEJBDEiBCCzCjxmM2k6eScGL47p82MVCy30H8Sl
# X/tsk28bpVkjvTANBgkqhkiG9w0BAQEFAASCAQDa8do9gY8sHWymERu97LV+K1nO
# RRU/EbJwDJ+VE+2u6+8F2iALM/AhiClFOu87LdSPRVYgxs7siHa5dB8jAN+FD8iq
# HPGXTHa1ljMXaeD93PPYvkD7T7y2nEZ6RcUqs810QUQxmbCtAOnAYva5piY5c8Sd
# pQDriunjEHokewiE+F1wN+LM+uEPw24zllmlvgIU0eTzxInNWxEUDVUn9ZiviOGv
# LEmWCg1D2iHO2HdEcCbk5Jtzwl7ALQuTKY9eG9B0qL73ohQ76CoYfUkpo7FJ1Iln
# 6pgjyZNtJQT5PitUuXwQVSkqkiF490Grrev4JlpsOxq7v/0RGPMEPBhBkSBf
# SIG # End signature block
